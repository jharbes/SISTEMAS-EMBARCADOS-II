CCS PCH C Compiler, Version 5.099, 54900               15-mai-23 16:57

               Filename:   G:\Meu Drive\CEFET 2023\Sistemas de Informação 2023_1\Sistemas Embarcados 2\05d-Aula - 15MAI23 - Teclado - LCD - Servo\Exemplo_9 Servo_PIC18F46K22\servo.lst

               ROM used:   5160 bytes (8%)
                           Largest free fragment is 60372
               RAM used:   84 (2%) at main() level
                           169 (4%) worst case
               Stack used: 0 locations
               Stack size: 31

*
00000:  GOTO   1268
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  BTFSS  F9D.0
00056:  GOTO   0060
0005A:  BTFSC  F9E.0
0005C:  GOTO   0A10
00060:  MOVFF  0E,00
00064:  MOVFF  0F,01
00068:  MOVFF  10,02
0006C:  MOVFF  11,03
00070:  MOVFF  0C,FE9
00074:  MOVFF  07,FEA
00078:  BSF    07.7
0007A:  MOVFF  08,FE1
0007E:  MOVFF  09,FE2
00082:  MOVFF  0A,FD9
00086:  MOVFF  0B,FDA
0008A:  MOVFF  12,FF3
0008E:  MOVFF  13,FF4
00092:  MOVFF  14,FFA
00096:  MOVFF  15,FF5
0009A:  MOVFF  16,FF6
0009E:  MOVFF  17,FF7
000A2:  MOVF   04,W
000A4:  MOVFF  06,FE0
000A8:  MOVFF  05,FD8
000AC:  RETFIE 0
.................... #include <servo.h>
.................... #include <18F46K22.h>
.................... //////////// Standard Header file for the PIC18F46K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46K22
000AE:  MOVLW  8E
000B0:  MOVWF  00
000B2:  MOVFF  90,01
000B6:  MOVFF  8F,02
000BA:  CLRF   03
000BC:  MOVF   01,F
000BE:  BNZ   00D2
000C0:  MOVFF  02,01
000C4:  CLRF   02
000C6:  MOVLW  08
000C8:  SUBWF  00,F
000CA:  MOVF   01,F
000CC:  BNZ   00D2
000CE:  CLRF   00
000D0:  BRA    00E2
000D2:  BCF    FD8.0
000D4:  BTFSC  01.7
000D6:  BRA    00E0
000D8:  RLCF   02,F
000DA:  RLCF   01,F
000DC:  DECF   00,F
000DE:  BRA    00D2
000E0:  BCF    01.7
000E2:  RETURN 0
000E4:  MOVF   x9C,W
000E6:  BTFSC  FD8.2
000E8:  BRA    01CC
000EA:  MOVWF  00
000EC:  MOVF   xA0,W
000EE:  BTFSC  FD8.2
000F0:  BRA    01CC
000F2:  ADDWF  00,F
000F4:  BNC   00FE
000F6:  MOVLW  81
000F8:  ADDWF  00,F
000FA:  BC    01CC
000FC:  BRA    0106
000FE:  MOVLW  7F
00100:  SUBWF  00,F
00102:  BNC   01CC
00104:  BZ    01CC
00106:  MOVFF  9D,A4
0010A:  MOVF   xA1,W
0010C:  XORWF  xA4,F
0010E:  BSF    x9D.7
00110:  BSF    xA1.7
00112:  MOVF   x9F,W
00114:  MULWF  xA3
00116:  MOVFF  FF4,A6
0011A:  MOVF   x9E,W
0011C:  MULWF  xA2
0011E:  MOVFF  FF4,03
00122:  MOVFF  FF3,A5
00126:  MULWF  xA3
00128:  MOVF   FF3,W
0012A:  ADDWF  xA6,F
0012C:  MOVF   FF4,W
0012E:  ADDWFC xA5,F
00130:  MOVLW  00
00132:  ADDWFC 03,F
00134:  MOVF   x9F,W
00136:  MULWF  xA2
00138:  MOVF   FF3,W
0013A:  ADDWF  xA6,F
0013C:  MOVF   FF4,W
0013E:  ADDWFC xA5,F
00140:  MOVLW  00
00142:  CLRF   02
00144:  ADDWFC 03,F
00146:  ADDWFC 02,F
00148:  MOVF   x9D,W
0014A:  MULWF  xA3
0014C:  MOVF   FF3,W
0014E:  ADDWF  xA5,F
00150:  MOVF   FF4,W
00152:  ADDWFC 03,F
00154:  MOVLW  00
00156:  ADDWFC 02,F
00158:  MOVF   x9D,W
0015A:  MULWF  xA2
0015C:  MOVF   FF3,W
0015E:  ADDWF  03,F
00160:  MOVF   FF4,W
00162:  ADDWFC 02,F
00164:  MOVLW  00
00166:  CLRF   01
00168:  ADDWFC 01,F
0016A:  MOVF   x9F,W
0016C:  MULWF  xA1
0016E:  MOVF   FF3,W
00170:  ADDWF  xA5,F
00172:  MOVF   FF4,W
00174:  ADDWFC 03,F
00176:  MOVLW  00
00178:  ADDWFC 02,F
0017A:  ADDWFC 01,F
0017C:  MOVF   x9E,W
0017E:  MULWF  xA1
00180:  MOVF   FF3,W
00182:  ADDWF  03,F
00184:  MOVF   FF4,W
00186:  ADDWFC 02,F
00188:  MOVLW  00
0018A:  ADDWFC 01,F
0018C:  MOVF   x9D,W
0018E:  MULWF  xA1
00190:  MOVF   FF3,W
00192:  ADDWF  02,F
00194:  MOVF   FF4,W
00196:  ADDWFC 01,F
00198:  INCF   00,F
0019A:  BTFSC  01.7
0019C:  BRA    01A8
0019E:  RLCF   xA5,F
001A0:  RLCF   03,F
001A2:  RLCF   02,F
001A4:  RLCF   01,F
001A6:  DECF   00,F
001A8:  MOVLW  00
001AA:  BTFSS  xA5.7
001AC:  BRA    01C2
001AE:  INCF   03,F
001B0:  ADDWFC 02,F
001B2:  ADDWFC 01,F
001B4:  MOVF   01,W
001B6:  BNZ   01C2
001B8:  MOVF   02,W
001BA:  BNZ   01C2
001BC:  MOVF   03,W
001BE:  BNZ   01C2
001C0:  INCF   00,F
001C2:  BTFSC  xA4.7
001C4:  BSF    01.7
001C6:  BTFSS  xA4.7
001C8:  BCF    01.7
001CA:  BRA    01D4
001CC:  CLRF   00
001CE:  CLRF   01
001D0:  CLRF   02
001D2:  CLRF   03
001D4:  RETURN 0
001D6:  MOVF   x93,W
001D8:  BTFSC  FD8.2
001DA:  BRA    0326
001DC:  MOVWF  x9F
001DE:  MOVF   x97,W
001E0:  BTFSC  FD8.2
001E2:  BRA    0326
001E4:  SUBWF  x9F,F
001E6:  BNC   01F2
001E8:  MOVLW  7F
001EA:  ADDWF  x9F,F
001EC:  BTFSC  FD8.0
001EE:  BRA    0326
001F0:  BRA    01FE
001F2:  MOVLW  81
001F4:  SUBWF  x9F,F
001F6:  BTFSS  FD8.0
001F8:  BRA    0326
001FA:  BTFSC  FD8.2
001FC:  BRA    0326
001FE:  MOVFF  9F,00
00202:  CLRF   01
00204:  CLRF   02
00206:  CLRF   03
00208:  CLRF   x9E
0020A:  MOVFF  94,9D
0020E:  BSF    x9D.7
00210:  MOVFF  95,9C
00214:  MOVFF  96,9B
00218:  MOVLW  19
0021A:  MOVWF  x9F
0021C:  MOVF   x9A,W
0021E:  SUBWF  x9B,F
00220:  BC    023C
00222:  MOVLW  01
00224:  SUBWF  x9C,F
00226:  BC    023C
00228:  SUBWF  x9D,F
0022A:  BC    023C
0022C:  SUBWF  x9E,F
0022E:  BC    023C
00230:  INCF   x9E,F
00232:  INCF   x9D,F
00234:  INCF   x9C,F
00236:  MOVF   x9A,W
00238:  ADDWF  x9B,F
0023A:  BRA    028C
0023C:  MOVF   x99,W
0023E:  SUBWF  x9C,F
00240:  BC    0266
00242:  MOVLW  01
00244:  SUBWF  x9D,F
00246:  BC    0266
00248:  SUBWF  x9E,F
0024A:  BC    0266
0024C:  INCF   x9E,F
0024E:  INCF   x9D,F
00250:  MOVF   x99,W
00252:  ADDWF  x9C,F
00254:  MOVF   x9A,W
00256:  ADDWF  x9B,F
00258:  BNC   028C
0025A:  INCF   x9C,F
0025C:  BNZ   028C
0025E:  INCF   x9D,F
00260:  BNZ   028C
00262:  INCF   x9E,F
00264:  BRA    028C
00266:  MOVF   x98,W
00268:  IORLW  80
0026A:  SUBWF  x9D,F
0026C:  BC    028A
0026E:  MOVLW  01
00270:  SUBWF  x9E,F
00272:  BC    028A
00274:  INCF   x9E,F
00276:  MOVF   x98,W
00278:  IORLW  80
0027A:  ADDWF  x9D,F
0027C:  MOVF   x99,W
0027E:  ADDWF  x9C,F
00280:  BNC   0254
00282:  INCF   x9D,F
00284:  BNZ   0254
00286:  INCF   x9E,F
00288:  BRA    0254
0028A:  BSF    03.0
0028C:  DECFSZ x9F,F
0028E:  BRA    0292
00290:  BRA    02A8
00292:  BCF    FD8.0
00294:  RLCF   x9B,F
00296:  RLCF   x9C,F
00298:  RLCF   x9D,F
0029A:  RLCF   x9E,F
0029C:  BCF    FD8.0
0029E:  RLCF   03,F
002A0:  RLCF   02,F
002A2:  RLCF   01,F
002A4:  RLCF   xA0,F
002A6:  BRA    021C
002A8:  BTFSS  xA0.0
002AA:  BRA    02B8
002AC:  BCF    FD8.0
002AE:  RRCF   01,F
002B0:  RRCF   02,F
002B2:  RRCF   03,F
002B4:  RRCF   xA0,F
002B6:  BRA    02BC
002B8:  DECF   00,F
002BA:  BZ    0326
002BC:  BTFSC  xA0.7
002BE:  BRA    02FC
002C0:  BCF    FD8.0
002C2:  RLCF   x9B,F
002C4:  RLCF   x9C,F
002C6:  RLCF   x9D,F
002C8:  RLCF   x9E,F
002CA:  MOVF   x9A,W
002CC:  SUBWF  x9B,F
002CE:  BC    02DE
002D0:  MOVLW  01
002D2:  SUBWF  x9C,F
002D4:  BC    02DE
002D6:  SUBWF  x9D,F
002D8:  BC    02DE
002DA:  SUBWF  x9E,F
002DC:  BNC   0312
002DE:  MOVF   x99,W
002E0:  SUBWF  x9C,F
002E2:  BC    02EE
002E4:  MOVLW  01
002E6:  SUBWF  x9D,F
002E8:  BC    02EE
002EA:  SUBWF  x9E,F
002EC:  BNC   0312
002EE:  MOVF   x98,W
002F0:  IORLW  80
002F2:  SUBWF  x9D,F
002F4:  BC    02FC
002F6:  MOVLW  01
002F8:  SUBWF  x9E,F
002FA:  BNC   0312
002FC:  INCF   03,F
002FE:  BNZ   0312
00300:  INCF   02,F
00302:  BNZ   0312
00304:  INCF   01,F
00306:  BNZ   0312
00308:  INCF   00,F
0030A:  BZ    0326
0030C:  RRCF   01,F
0030E:  RRCF   02,F
00310:  RRCF   03,F
00312:  MOVFF  94,9F
00316:  MOVF   x98,W
00318:  XORWF  x9F,F
0031A:  BTFSS  x9F.7
0031C:  BRA    0322
0031E:  BSF    01.7
00320:  BRA    032E
00322:  BCF    01.7
00324:  BRA    032E
00326:  CLRF   00
00328:  CLRF   01
0032A:  CLRF   02
0032C:  CLRF   03
0032E:  RETURN 0
*
00472:  MOVF   x9C,W
00474:  SUBLW  B6
00476:  MOVWF  x9C
00478:  CLRF   03
0047A:  MOVFF  9D,A0
0047E:  BSF    x9D.7
00480:  BCF    FD8.0
00482:  RRCF   x9D,F
00484:  RRCF   x9E,F
00486:  RRCF   x9F,F
00488:  RRCF   03,F
0048A:  RRCF   02,F
0048C:  RRCF   01,F
0048E:  RRCF   00,F
00490:  DECFSZ x9C,F
00492:  BRA    0480
00494:  BTFSS  xA0.7
00496:  BRA    04AE
00498:  COMF   00,F
0049A:  COMF   01,F
0049C:  COMF   02,F
0049E:  COMF   03,F
004A0:  INCF   00,F
004A2:  BTFSC  FD8.2
004A4:  INCF   01,F
004A6:  BTFSC  FD8.2
004A8:  INCF   02,F
004AA:  BTFSC  FD8.2
004AC:  INCF   03,F
004AE:  GOTO   0604 (RETURN)
004B2:  BTFSC  FD8.1
004B4:  BRA    04BC
004B6:  CLRF   FEA
004B8:  MOVLW  A4
004BA:  MOVWF  FE9
004BC:  CLRF   00
004BE:  CLRF   01
004C0:  CLRF   02
004C2:  CLRF   03
004C4:  CLRF   xA4
004C6:  CLRF   xA5
004C8:  CLRF   xA6
004CA:  CLRF   xA7
004CC:  MOVF   xA3,W
004CE:  IORWF  xA2,W
004D0:  IORWF  xA1,W
004D2:  IORWF  xA0,W
004D4:  BZ    052E
004D6:  MOVLW  20
004D8:  MOVWF  xA8
004DA:  BCF    FD8.0
004DC:  RLCF   x9C,F
004DE:  RLCF   x9D,F
004E0:  RLCF   x9E,F
004E2:  RLCF   x9F,F
004E4:  RLCF   xA4,F
004E6:  RLCF   xA5,F
004E8:  RLCF   xA6,F
004EA:  RLCF   xA7,F
004EC:  MOVF   xA3,W
004EE:  SUBWF  xA7,W
004F0:  BNZ   0502
004F2:  MOVF   xA2,W
004F4:  SUBWF  xA6,W
004F6:  BNZ   0502
004F8:  MOVF   xA1,W
004FA:  SUBWF  xA5,W
004FC:  BNZ   0502
004FE:  MOVF   xA0,W
00500:  SUBWF  xA4,W
00502:  BNC   0522
00504:  MOVF   xA0,W
00506:  SUBWF  xA4,F
00508:  MOVF   xA1,W
0050A:  BTFSS  FD8.0
0050C:  INCFSZ xA1,W
0050E:  SUBWF  xA5,F
00510:  MOVF   xA2,W
00512:  BTFSS  FD8.0
00514:  INCFSZ xA2,W
00516:  SUBWF  xA6,F
00518:  MOVF   xA3,W
0051A:  BTFSS  FD8.0
0051C:  INCFSZ xA3,W
0051E:  SUBWF  xA7,F
00520:  BSF    FD8.0
00522:  RLCF   00,F
00524:  RLCF   01,F
00526:  RLCF   02,F
00528:  RLCF   03,F
0052A:  DECFSZ xA8,F
0052C:  BRA    04DA
0052E:  MOVFF  A4,FEF
00532:  MOVFF  A5,FEC
00536:  MOVFF  A6,FEC
0053A:  MOVFF  A7,FEC
0053E:  RETURN 0
*
005B6:  MOVF   FE9,W
005B8:  MOVWF  x94
005BA:  MOVF   x93,W
005BC:  MOVWF  x96
005BE:  BZ    05F2
005C0:  MOVFF  92,9F
005C4:  MOVFF  91,9E
005C8:  MOVFF  90,9D
005CC:  MOVFF  8F,9C
005D0:  CLRF   xA3
005D2:  CLRF   xA2
005D4:  MOVLW  20
005D6:  MOVWF  xA1
005D8:  MOVLW  82
005DA:  MOVWF  xA0
005DC:  RCALL  00E4
005DE:  MOVFF  03,92
005E2:  MOVFF  02,91
005E6:  MOVFF  01,90
005EA:  MOVFF  00,8F
005EE:  DECFSZ x96,F
005F0:  BRA    05C0
005F2:  MOVFF  92,9F
005F6:  MOVFF  91,9E
005FA:  MOVFF  90,9D
005FE:  MOVFF  8F,9C
00602:  BRA    0472
00604:  MOVFF  03,92
00608:  MOVFF  02,91
0060C:  MOVFF  01,90
00610:  MOVFF  00,8F
00614:  BTFSS  x92.7
00616:  BRA    0632
00618:  DECF   x94,F
0061A:  BSF    x94.5
0061C:  COMF   x8F,F
0061E:  COMF   x90,F
00620:  COMF   x91,F
00622:  COMF   x92,F
00624:  INCF   x8F,F
00626:  BTFSC  FD8.2
00628:  INCF   x90,F
0062A:  BTFSC  FD8.2
0062C:  INCF   x91,F
0062E:  BTFSC  FD8.2
00630:  INCF   x92,F
00632:  MOVLW  3B
00634:  MOVWF  x9B
00636:  MOVLW  9A
00638:  MOVWF  x9A
0063A:  MOVLW  CA
0063C:  MOVWF  x99
0063E:  CLRF   x98
00640:  MOVLW  0A
00642:  MOVWF  x96
00644:  MOVF   x93,W
00646:  BTFSC  FD8.2
00648:  INCF   x94,F
0064A:  BSF    FD8.1
0064C:  CLRF   FEA
0064E:  MOVLW  8F
00650:  MOVWF  FE9
00652:  MOVFF  92,9F
00656:  MOVFF  91,9E
0065A:  MOVFF  90,9D
0065E:  MOVFF  8F,9C
00662:  MOVFF  9B,A3
00666:  MOVFF  9A,A2
0066A:  MOVFF  99,A1
0066E:  MOVFF  98,A0
00672:  RCALL  04B2
00674:  MOVF   01,W
00676:  MOVF   00,F
00678:  BNZ   0698
0067A:  INCF   x93,W
0067C:  SUBWF  x96,W
0067E:  BZ    0698
00680:  MOVF   x94,W
00682:  BZ    069C
00684:  ANDLW  0F
00686:  SUBWF  x96,W
00688:  BZ    068C
0068A:  BC    06FA
0068C:  BTFSC  x94.7
0068E:  BRA    06FA
00690:  BTFSC  x94.6
00692:  BRA    069C
00694:  MOVLW  20
00696:  BRA    06F2
00698:  MOVLW  20
0069A:  ANDWF  x94,F
0069C:  BTFSS  x94.5
0069E:  BRA    06B8
006A0:  BCF    x94.5
006A2:  MOVF   x93,W
006A4:  BTFSS  FD8.2
006A6:  DECF   x94,F
006A8:  MOVF   00,W
006AA:  MOVWF  x94
006AC:  MOVLW  2D
006AE:  MOVWF  x9C
006B0:  RCALL  0566
006B2:  MOVF   x94,W
006B4:  MOVWF  00
006B6:  CLRF   x94
006B8:  MOVF   x93,W
006BA:  SUBWF  x96,W
006BC:  BNZ   06D2
006BE:  MOVF   00,W
006C0:  MOVWF  x94
006C2:  MOVLW  2E
006C4:  MOVWF  x9C
006C6:  RCALL  0566
006C8:  MOVF   x94,W
006CA:  MOVWF  00
006CC:  MOVLW  20
006CE:  ANDWF  x94,F
006D0:  MOVLW  00
006D2:  MOVLW  30
006D4:  BTFSS  x94.5
006D6:  BRA    06F2
006D8:  BCF    x94.5
006DA:  MOVF   x93,W
006DC:  BTFSS  FD8.2
006DE:  DECF   x94,F
006E0:  MOVF   00,W
006E2:  MOVWF  x94
006E4:  MOVLW  2D
006E6:  MOVWF  x9C
006E8:  RCALL  0566
006EA:  MOVF   x94,W
006EC:  MOVWF  00
006EE:  CLRF   x94
006F0:  MOVLW  30
006F2:  ADDWF  00,F
006F4:  MOVFF  00,9C
006F8:  RCALL  0566
006FA:  BCF    FD8.1
006FC:  MOVFF  9B,9F
00700:  MOVFF  9A,9E
00704:  MOVFF  99,9D
00708:  MOVFF  98,9C
0070C:  CLRF   xA3
0070E:  CLRF   xA2
00710:  CLRF   xA1
00712:  MOVLW  0A
00714:  MOVWF  xA0
00716:  RCALL  04B2
00718:  MOVFF  03,9B
0071C:  MOVFF  02,9A
00720:  MOVFF  01,99
00724:  MOVFF  00,98
00728:  DECFSZ x96,F
0072A:  BRA    064A
0072C:  GOTO   0ACA (RETURN)
00730:  TBLRD*+
00732:  MOVFF  FF6,90
00736:  MOVFF  FF7,91
0073A:  MOVFF  FF5,9C
0073E:  RCALL  0566
00740:  MOVFF  90,FF6
00744:  MOVFF  91,FF7
00748:  DECFSZ x8F,F
0074A:  BRA    0730
0074C:  GOTO   0AD8 (RETURN)
00750:  MOVLW  80
00752:  BTFSC  FD8.1
00754:  XORWF  x94,F
00756:  CLRF   x99
00758:  CLRF   x9A
0075A:  MOVFF  90,98
0075E:  MOVF   x94,W
00760:  XORWF  x98,F
00762:  MOVF   x8F,W
00764:  BTFSC  FD8.2
00766:  BRA    0920
00768:  MOVWF  x97
0076A:  MOVWF  00
0076C:  MOVF   x93,W
0076E:  BTFSC  FD8.2
00770:  BRA    0932
00772:  SUBWF  x97,F
00774:  BTFSC  FD8.2
00776:  BRA    087A
00778:  BNC   07F4
0077A:  MOVFF  94,9D
0077E:  BSF    x9D.7
00780:  MOVFF  95,9C
00784:  MOVFF  96,9B
00788:  CLRF   x9A
0078A:  BCF    FD8.0
0078C:  RRCF   x9D,F
0078E:  RRCF   x9C,F
00790:  RRCF   x9B,F
00792:  RRCF   x9A,F
00794:  DECFSZ x97,F
00796:  BRA    0788
00798:  BTFSS  x98.7
0079A:  BRA    07A2
0079C:  BSF    x99.0
0079E:  BRA    095A
007A0:  BCF    x99.0
007A2:  BCF    x97.0
007A4:  BSF    x99.4
007A6:  CLRF   FEA
007A8:  MOVLW  92
007AA:  MOVWF  FE9
007AC:  BRA    0980
007AE:  BCF    x99.4
007B0:  BTFSC  x98.7
007B2:  BRA    07C8
007B4:  BTFSS  x97.0
007B6:  BRA    07DE
007B8:  RRCF   x9D,F
007BA:  RRCF   x9C,F
007BC:  RRCF   x9B,F
007BE:  RRCF   x9A,F
007C0:  INCF   00,F
007C2:  BTFSC  FD8.2
007C4:  BRA    0950
007C6:  BRA    07DE
007C8:  BTFSC  x9D.7
007CA:  BRA    07E4
007CC:  BCF    FD8.0
007CE:  RLCF   x9A,F
007D0:  RLCF   x9B,F
007D2:  RLCF   x9C,F
007D4:  RLCF   x9D,F
007D6:  DECF   00,F
007D8:  BTFSC  FD8.2
007DA:  BRA    0950
007DC:  BRA    07C8
007DE:  BSF    x99.6
007E0:  BRA    08B8
007E2:  BCF    x99.6
007E4:  MOVFF  90,98
007E8:  BTFSS  x90.7
007EA:  BRA    07F0
007EC:  BSF    x9D.7
007EE:  BRA    0942
007F0:  BCF    x9D.7
007F2:  BRA    0942
007F4:  MOVFF  93,97
007F8:  MOVFF  93,00
007FC:  MOVF   x8F,W
007FE:  SUBWF  x97,F
00800:  MOVFF  90,9D
00804:  BSF    x9D.7
00806:  MOVFF  91,9C
0080A:  MOVFF  92,9B
0080E:  CLRF   x9A
00810:  BCF    FD8.0
00812:  RRCF   x9D,F
00814:  RRCF   x9C,F
00816:  RRCF   x9B,F
00818:  RRCF   x9A,F
0081A:  DECFSZ x97,F
0081C:  BRA    080E
0081E:  BTFSS  x98.7
00820:  BRA    0828
00822:  BSF    x99.1
00824:  BRA    095A
00826:  BCF    x99.1
00828:  BCF    x97.0
0082A:  BSF    x99.5
0082C:  CLRF   FEA
0082E:  MOVLW  96
00830:  MOVWF  FE9
00832:  BRA    0980
00834:  BCF    x99.5
00836:  BTFSC  x98.7
00838:  BRA    084E
0083A:  BTFSS  x97.0
0083C:  BRA    0864
0083E:  RRCF   x9D,F
00840:  RRCF   x9C,F
00842:  RRCF   x9B,F
00844:  RRCF   x9A,F
00846:  INCF   00,F
00848:  BTFSC  FD8.2
0084A:  BRA    0950
0084C:  BRA    0864
0084E:  BTFSC  x9D.7
00850:  BRA    086A
00852:  BCF    FD8.0
00854:  RLCF   x9A,F
00856:  RLCF   x9B,F
00858:  RLCF   x9C,F
0085A:  RLCF   x9D,F
0085C:  DECF   00,F
0085E:  BTFSC  FD8.2
00860:  BRA    0950
00862:  BRA    084E
00864:  BSF    x99.7
00866:  BRA    08B8
00868:  BCF    x99.7
0086A:  MOVFF  94,98
0086E:  BTFSS  x94.7
00870:  BRA    0876
00872:  BSF    x9D.7
00874:  BRA    0942
00876:  BCF    x9D.7
00878:  BRA    0942
0087A:  MOVFF  94,9D
0087E:  BSF    x9D.7
00880:  MOVFF  95,9C
00884:  MOVFF  96,9B
00888:  BTFSS  x98.7
0088A:  BRA    0894
0088C:  BCF    x9D.7
0088E:  BSF    x99.2
00890:  BRA    095A
00892:  BCF    x99.2
00894:  CLRF   x9A
00896:  BCF    x97.0
00898:  CLRF   FEA
0089A:  MOVLW  92
0089C:  MOVWF  FE9
0089E:  BRA    0980
008A0:  BTFSC  x98.7
008A2:  BRA    08DC
008A4:  MOVFF  90,98
008A8:  BTFSS  x97.0
008AA:  BRA    08B8
008AC:  RRCF   x9D,F
008AE:  RRCF   x9C,F
008B0:  RRCF   x9B,F
008B2:  RRCF   x9A,F
008B4:  INCF   00,F
008B6:  BZ    0950
008B8:  BTFSS  x9A.7
008BA:  BRA    08D2
008BC:  INCF   x9B,F
008BE:  BNZ   08D2
008C0:  INCF   x9C,F
008C2:  BNZ   08D2
008C4:  INCF   x9D,F
008C6:  BNZ   08D2
008C8:  RRCF   x9D,F
008CA:  RRCF   x9C,F
008CC:  RRCF   x9B,F
008CE:  INCF   00,F
008D0:  BZ    0950
008D2:  BTFSC  x99.6
008D4:  BRA    07E2
008D6:  BTFSC  x99.7
008D8:  BRA    0868
008DA:  BRA    0914
008DC:  MOVLW  80
008DE:  XORWF  x9D,F
008E0:  BTFSS  x9D.7
008E2:  BRA    08EC
008E4:  BRA    095A
008E6:  MOVFF  94,98
008EA:  BRA    0900
008EC:  MOVFF  90,98
008F0:  MOVF   x9D,F
008F2:  BNZ   0900
008F4:  MOVF   x9C,F
008F6:  BNZ   0900
008F8:  MOVF   x9B,F
008FA:  BNZ   0900
008FC:  CLRF   00
008FE:  BRA    0942
00900:  BTFSC  x9D.7
00902:  BRA    0914
00904:  BCF    FD8.0
00906:  RLCF   x9A,F
00908:  RLCF   x9B,F
0090A:  RLCF   x9C,F
0090C:  RLCF   x9D,F
0090E:  DECFSZ 00,F
00910:  BRA    0900
00912:  BRA    0950
00914:  BTFSS  x98.7
00916:  BRA    091C
00918:  BSF    x9D.7
0091A:  BRA    0942
0091C:  BCF    x9D.7
0091E:  BRA    0942
00920:  MOVFF  93,00
00924:  MOVFF  94,9D
00928:  MOVFF  95,9C
0092C:  MOVFF  96,9B
00930:  BRA    0942
00932:  MOVFF  8F,00
00936:  MOVFF  90,9D
0093A:  MOVFF  91,9C
0093E:  MOVFF  92,9B
00942:  MOVFF  9D,01
00946:  MOVFF  9C,02
0094A:  MOVFF  9B,03
0094E:  BRA    09B8
00950:  CLRF   00
00952:  CLRF   01
00954:  CLRF   02
00956:  CLRF   03
00958:  BRA    09B8
0095A:  CLRF   x9A
0095C:  COMF   x9B,F
0095E:  COMF   x9C,F
00960:  COMF   x9D,F
00962:  COMF   x9A,F
00964:  INCF   x9A,F
00966:  BNZ   0972
00968:  INCF   x9B,F
0096A:  BNZ   0972
0096C:  INCF   x9C,F
0096E:  BNZ   0972
00970:  INCF   x9D,F
00972:  BTFSC  x99.0
00974:  BRA    07A0
00976:  BTFSC  x99.1
00978:  BRA    0826
0097A:  BTFSC  x99.2
0097C:  BRA    0892
0097E:  BRA    08E6
00980:  MOVF   FEF,W
00982:  ADDWF  x9B,F
00984:  BNC   0990
00986:  INCF   x9C,F
00988:  BNZ   0990
0098A:  INCF   x9D,F
0098C:  BTFSC  FD8.2
0098E:  BSF    x97.0
00990:  MOVF   FED,F
00992:  MOVF   FEF,W
00994:  ADDWF  x9C,F
00996:  BNC   099E
00998:  INCF   x9D,F
0099A:  BTFSC  FD8.2
0099C:  BSF    x97.0
0099E:  MOVF   FED,F
009A0:  MOVF   FEF,W
009A2:  BTFSC  FEF.7
009A4:  BRA    09A8
009A6:  XORLW  80
009A8:  ADDWF  x9D,F
009AA:  BTFSC  FD8.0
009AC:  BSF    x97.0
009AE:  BTFSC  x99.4
009B0:  BRA    07AE
009B2:  BTFSC  x99.5
009B4:  BRA    0834
009B6:  BRA    08A0
009B8:  RETURN 0
009BA:  MOVLW  8E
009BC:  MOVWF  00
009BE:  MOVF   x8F,W
009C0:  SUBWF  00,F
009C2:  MOVFF  90,02
009C6:  MOVFF  91,01
009CA:  BSF    02.7
009CC:  MOVF   00,F
009CE:  BZ    09E2
009D0:  BCF    FD8.0
009D2:  MOVF   02,F
009D4:  BNZ   09DA
009D6:  MOVF   01,F
009D8:  BZ    09E2
009DA:  RRCF   02,F
009DC:  RRCF   01,F
009DE:  DECFSZ 00,F
009E0:  BRA    09D0
009E2:  BTFSS  x90.7
009E4:  BRA    09F0
009E6:  COMF   01,F
009E8:  COMF   02,F
009EA:  INCF   01,F
009EC:  BTFSC  FD8.2
009EE:  INCF   02,F
009F0:  RETURN 0
*
00B7C:  DATA 25,32
00B7E:  DATA 2E,32
00B80:  DATA 66,20
00B82:  DATA 76,6F
00B84:  DATA 6C,74
00B86:  DATA 73,20
00B88:  DATA 20,20
00B8A:  DATA 20,20
00B8C:  DATA 00,00
00B8E:  DATA 50,72
00B90:  DATA 6F,6A
00B92:  DATA 65,74
00B94:  DATA 6F,20
00B96:  DATA 20,53
00B98:  DATA 45,52
00B9A:  DATA 56,4F
00B9C:  DATA 0A,0D
00B9E:  DATA 00,00
00BA0:  DATA 50,72
00BA2:  DATA 6F,6A
00BA4:  DATA 65,74
00BA6:  DATA 6F,20
00BA8:  DATA 20,53
00BAA:  DATA 45,52
00BAC:  DATA 56,4F
00BAE:  DATA 0A,0D
00BB0:  DATA 00,00
00BB2:  DATA 0A,0D
00BB4:  DATA 44,69
00BB6:  DATA 67,69
00BB8:  DATA 74,65
00BBA:  DATA 20,6F
00BBC:  DATA 20,61
00BBE:  DATA 6E,67
00BC0:  DATA 75,6C
00BC2:  DATA 6F,20
00BC4:  DATA 64,6F
00BC6:  DATA 20,73
00BC8:  DATA 65,72
00BCA:  DATA 76,6F
00BCC:  DATA 20,65
00BCE:  DATA 6E,74
00BD0:  DATA 72,65
00BD2:  DATA 20,20
00BD4:  DATA 30,20
00BD6:  DATA 65,20
00BD8:  DATA 31,38
00BDA:  DATA 30,20
00BDC:  DATA 67,72
00BDE:  DATA 61,75
00BE0:  DATA 73,3A
00BE2:  DATA 0D,0A
00BE4:  DATA 00,00
00BE6:  DATA 0A,0D
00BE8:  DATA 41,6E
00BEA:  DATA 67,75
00BEC:  DATA 6C,6F
00BEE:  DATA 20,64
00BF0:  DATA 69,67
00BF2:  DATA 69,74
00BF4:  DATA 61,64
00BF6:  DATA 6F,3D
00BF8:  DATA 25,4C
00BFA:  DATA 55,0D
00BFC:  DATA 0A,00
*
00CC8:  TBLRD*+
00CCA:  MOVF   FF5,F
00CCC:  BZ    0CE8
00CCE:  MOVFF  FF6,53
00CD2:  MOVFF  FF7,54
00CD6:  MOVF   FF5,W
00CD8:  BTFSS  F9E.4
00CDA:  BRA    0CD8
00CDC:  MOVWF  FAD
00CDE:  MOVFF  53,FF6
00CE2:  MOVFF  54,FF7
00CE6:  BRA    0CC8
00CE8:  RETURN 0
00CEA:  TBLRD*+
00CEC:  MOVF   FF5,F
00CEE:  BZ    0D14
00CF0:  MOVFF  FF6,53
00CF4:  MOVFF  FF7,54
00CF8:  CLRF   19
00CFA:  BTFSC  FF2.7
00CFC:  BSF    19.7
00CFE:  BCF    FF2.7
00D00:  MOVFF  FF5,9C
00D04:  RCALL  0566
00D06:  BTFSC  19.7
00D08:  BSF    FF2.7
00D0A:  MOVFF  53,FF6
00D0E:  MOVFF  54,FF7
00D12:  BRA    0CEA
00D14:  GOTO   130C (RETURN)
*
00DE2:  MOVF   x88,W
00DE4:  XORWF  x8A,W
00DE6:  ANDLW  80
00DE8:  MOVWF  x8C
00DEA:  BTFSS  x88.7
00DEC:  BRA    0DF8
00DEE:  COMF   x87,F
00DF0:  COMF   x88,F
00DF2:  INCF   x87,F
00DF4:  BTFSC  FD8.2
00DF6:  INCF   x88,F
00DF8:  BTFSS  x8A.7
00DFA:  BRA    0E06
00DFC:  COMF   x89,F
00DFE:  COMF   x8A,F
00E00:  INCF   x89,F
00E02:  BTFSC  FD8.2
00E04:  INCF   x8A,F
00E06:  MOVF   x87,W
00E08:  MULWF  x89
00E0A:  MOVFF  FF3,01
00E0E:  MOVFF  FF4,00
00E12:  MULWF  x8A
00E14:  MOVF   FF3,W
00E16:  ADDWF  00,F
00E18:  MOVF   x88,W
00E1A:  MULWF  x89
00E1C:  MOVF   FF3,W
00E1E:  ADDWFC 00,W
00E20:  MOVWF  02
00E22:  BTFSS  x8C.7
00E24:  BRA    0E30
00E26:  COMF   01,F
00E28:  COMF   02,F
00E2A:  INCF   01,F
00E2C:  BTFSC  FD8.2
00E2E:  INCF   02,F
00E30:  GOTO   10D0 (RETURN)
*
01198:  TBLRD*+
0119A:  MOVFF  FF6,54
0119E:  MOVFF  FF7,55
011A2:  MOVF   FF5,W
011A4:  BTFSS  F9E.4
011A6:  BRA    11A4
011A8:  MOVWF  FAD
011AA:  MOVFF  54,FF6
011AE:  MOVFF  55,FF7
011B2:  DECFSZ 53,F
011B4:  BRA    1198
011B6:  GOTO   136C (RETURN)
011BA:  MOVFF  FEA,5B
011BE:  MOVFF  FE9,5A
011C2:  SWAPF  54,W
011C4:  IORLW  F0
011C6:  MOVWF  56
011C8:  ADDWF  56,F
011CA:  ADDLW  E2
011CC:  MOVWF  57
011CE:  ADDLW  32
011D0:  MOVWF  59
011D2:  MOVF   54,W
011D4:  ANDLW  0F
011D6:  ADDWF  57,F
011D8:  ADDWF  57,F
011DA:  ADDWF  59,F
011DC:  ADDLW  E9
011DE:  MOVWF  58
011E0:  ADDWF  58,F
011E2:  ADDWF  58,F
011E4:  SWAPF  53,W
011E6:  ANDLW  0F
011E8:  ADDWF  58,F
011EA:  ADDWF  59,F
011EC:  RLCF   58,F
011EE:  RLCF   59,F
011F0:  COMF   59,F
011F2:  RLCF   59,F
011F4:  MOVF   53,W
011F6:  ANDLW  0F
011F8:  ADDWF  59,F
011FA:  RLCF   56,F
011FC:  MOVLW  07
011FE:  MOVWF  55
01200:  MOVLW  0A
01202:  DECF   58,F
01204:  ADDWF  59,F
01206:  BNC   1202
01208:  DECF   57,F
0120A:  ADDWF  58,F
0120C:  BNC   1208
0120E:  DECF   56,F
01210:  ADDWF  57,F
01212:  BNC   120E
01214:  DECF   55,F
01216:  ADDWF  56,F
01218:  BNC   1214
0121A:  CLRF   FEA
0121C:  MOVLW  55
0121E:  MOVWF  FE9
01220:  MOVLW  07
01222:  ANDWF  5A,W
01224:  BCF    5A.6
01226:  ADDWF  FE9,F
01228:  MOVLW  00
0122A:  ADDWFC FEA,F
0122C:  MOVF   FE9,W
0122E:  SUBLW  59
01230:  BNZ   1238
01232:  MOVF   FEA,F
01234:  BNZ   1238
01236:  BSF    5A.6
01238:  MOVF   FEF,W
0123A:  MOVWF  00
0123C:  BNZ   124E
0123E:  BTFSC  5A.6
01240:  BRA    124E
01242:  BTFSC  5A.4
01244:  BRA    125E
01246:  BTFSC  5A.3
01248:  BRA    124E
0124A:  MOVLW  20
0124C:  BRA    1254
0124E:  BSF    5A.3
01250:  BCF    5A.4
01252:  MOVLW  30
01254:  ADDWF  00,F
01256:  MOVF   00,W
01258:  BTFSS  F9E.4
0125A:  BRA    1258
0125C:  MOVWF  FAD
0125E:  MOVF   FEE,W
01260:  BTFSS  5A.6
01262:  BRA    122C
01264:  GOTO   137A (RETURN)
.................... 
.................... #list
.................... 
.................... #device ADC=10
.................... 
.................... #use delay(internal=8MHz)
*
00540:  CLRF   FEA
00542:  MOVLW  9D
00544:  MOVWF  FE9
00546:  MOVF   FEF,W
00548:  BZ    0564
0054A:  MOVLW  02
0054C:  MOVWF  01
0054E:  CLRF   00
00550:  DECFSZ 00,F
00552:  BRA    0550
00554:  DECFSZ 01,F
00556:  BRA    054E
00558:  MOVLW  97
0055A:  MOVWF  00
0055C:  DECFSZ 00,F
0055E:  BRA    055C
00560:  DECFSZ FEF,F
00562:  BRA    054A
00564:  RETURN 0
*
009F2:  MOVLW  09
009F4:  SUBWF  x90,F
009F6:  BNC   0A0E
009F8:  CLRF   FEA
009FA:  MOVLW  90
009FC:  MOVWF  FE9
009FE:  BCF    FD8.0
00A00:  RRCF   FEF,F
00A02:  MOVF   FEF,W
00A04:  BZ    0A0E
00A06:  BRA    0A0A
00A08:  NOP   
00A0A:  DECFSZ FEF,F
00A0C:  BRA    0A08
00A0E:  RETURN 0
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=PORT1)
*
00D18:  BTFSS  F9E.4
00D1A:  BRA    0D18
00D1C:  MOVWF  FAD
00D1E:  GOTO   0D26 (RETURN)
.................... 
.................... // acesso aos pinos:
.................... #define LCD_ENABLE_PIN  PIN_E1
.................... #define LCD_RS_PIN      PIN_E0
.................... #define LCD_RW_PIN      PIN_E2
.................... #define LCD_DATA4       PIN_D4
.................... #define LCD_DATA5       PIN_D5
.................... #define LCD_DATA6       PIN_D6
.................... #define LCD_DATA7       PIN_D7 
.................... 
.................... #include <input.c>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                             input.c                               ////
.................... ////                                                                   ////
.................... //// Routines for reading user input over an RS232 stream.  User input ////
.................... //// is in ASCII form and converted to requested binary or float       ////
.................... //// format.                                                           ////
.................... ////                                                                   ////
.................... //// If STREAM_SERIAL_INPUT is defined, these routines will read from  ////
.................... //// that serial stream.  If not, uses the last #use rs232().          ////
.................... ////                                                                   ////
.................... //// Some of these routines are not available unless you #include      ////
.................... //// string.h and stdlib.h                                             ////
.................... ////                                                                   ////
.................... ////  int8 gethex() - read 2 char hex value from serial                ////
.................... ////                                                                   ////
.................... ////  get_string(s, max) - read max chars from serial and save to s    ////
.................... ////                                                                   ////
.................... ////  get_stringEdit(s, max) - similar to get_string(), but first it   ////
.................... ////     displays current string in s, allowing you to edit it.        ////
.................... ////                                                                   ////
.................... ////  int8 = get_Int8() -                                              ////
.................... ////  int16 = get_Int16() -                                            ////
.................... ////  int32 = get_Int32() -                                            ////
.................... ////  float = get_float() -                                            ////
.................... ////     Read value from serial.                                       ////
.................... ////                                                                   ////
.................... ////  int8 = get_Int8Edit(old) -                                       ////
.................... ////  int16 = get_Int16Edit(old) -                                     ////
.................... ////  int32 = get_Int32Edit(old) -                                     ////
.................... ////  float = get_floatEdit(old) -                                     ////
.................... ////     Similar to get_Int*() routines documented above, but first    ////
.................... ////     it displays old value allowing you to edit it.                ////
.................... ////                                                                   ////
.................... ////  int = get_int() -                                                ////
.................... ////  long = get_long() -                                              ////
.................... ////     Simlar to get_Int*() documented above, but return 'int' and   ////
.................... ////     'long' datatypes.  The size of these datatypes depends on     ////
.................... ////     the PIC architecture and compiler configuration.              ////
.................... ////                                                                   ////
.................... ////  int = get_intEdit(old) -                                         ////
.................... ////  long = get_longEdit(old) -                                       ////
.................... ////     Similar to get_int() and get_long() documented above,         ////
.................... ////     but first it displays old value allowing you to edit it.      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __INPUT_C__
.................... #define __INPUT_C__
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #ifndef InputKbhit
....................    #if defined(STREAM_SERIAL_INPUT)
....................       #define InputKbhit()    kbhit(STREAM_SERIAL_INPUT)
....................    #else
....................       #define InputKbhit()    kbhit()
....................    #endif
.................... #endif
.................... 
.................... #if !definedinc(InputPutc)
....................    #if defined(STREAM_SERIAL_INPUT)
....................       void InputPutc(char c)    {fputc(c, STREAM_SERIAL_INPUT);}
....................    #else
....................       void InputPutc(char c)    {putc(c);}
00D22:  MOVF   58,W
00D24:  BRA    0D18
00D26:  RETURN 0
....................    #endif
.................... #endif
.................... 
.................... #ifndef InputGetc
....................    #if defined(STREAM_SERIAL_INPUT)
....................       #define InputGetc()    fgetc(STREAM_SERIAL_INPUT)
....................    #else
....................       #define InputGetc()    getc()
....................    #endif
.................... #endif
.................... 
.................... unsigned int8 gethex1() {
....................    char digit;
.................... 
....................    digit = InputGetc();
.................... 
....................    InputPutc(digit);
.................... 
....................    if(digit<='9')
....................      return(digit-'0');
....................    else
....................      return((toupper(digit)-'A')+10);
.................... }
.................... 
.................... unsigned int8 gethex() {
....................    unsigned int8 lo,hi;
.................... 
....................    hi = gethex1();
....................    lo = gethex1();
....................    if(lo==0xdd)
....................      return(hi);
....................    else
....................      return( hi*16+lo );
.................... }
.................... 
.................... void get_string(char* s, unsigned int8 max) {
....................    unsigned int8 len;
....................    char c;
.................... 
....................    max-=2;
00D28:  MOVLW  02
00D2A:  SUBWF  55,F
....................    len=0;
00D2C:  CLRF   56
....................    do {
....................      c=InputGetc();
00D2E:  BTFSS  F9E.5
00D30:  BRA    0D2E
00D32:  MOVFF  FAE,57
....................      if(c==8) {  // Backspace
00D36:  MOVF   57,W
00D38:  SUBLW  08
00D3A:  BNZ   0D56
....................         if(len>0) {
00D3C:  MOVF   56,F
00D3E:  BZ    0D54
....................           len--;
00D40:  DECF   56,F
....................           InputPutc(c);
00D42:  MOVFF  57,58
00D46:  RCALL  0D22
....................           InputPutc(' ');
00D48:  MOVLW  20
00D4A:  MOVWF  58
00D4C:  RCALL  0D22
....................           InputPutc(c);
00D4E:  MOVFF  57,58
00D52:  RCALL  0D22
....................         }
....................      } else if ((c>=' ')&&(c<='~'))
00D54:  BRA    0D80
00D56:  MOVF   57,W
00D58:  SUBLW  1F
00D5A:  BC    0D80
00D5C:  MOVF   57,W
00D5E:  SUBLW  7E
00D60:  BNC   0D80
....................        if(len<=max) {
00D62:  MOVF   56,W
00D64:  SUBWF  55,W
00D66:  BNC   0D80
....................          s[len++]=c;
00D68:  MOVF   56,W
00D6A:  INCF   56,F
00D6C:  ADDWF  53,W
00D6E:  MOVWF  FE9
00D70:  MOVLW  00
00D72:  ADDWFC 54,W
00D74:  MOVWF  FEA
00D76:  MOVFF  57,FEF
....................          InputPutc(c);
00D7A:  MOVFF  57,58
00D7E:  RCALL  0D22
....................        }
....................    } while(c!=13);
00D80:  MOVF   57,W
00D82:  SUBLW  0D
00D84:  BNZ   0D2E
....................    s[len]=0;
00D86:  MOVF   56,W
00D88:  ADDWF  53,W
00D8A:  MOVWF  FE9
00D8C:  MOVLW  00
00D8E:  ADDWFC 54,W
00D90:  MOVWF  FEA
00D92:  CLRF   FEF
00D94:  GOTO   1344 (RETURN)
.................... }
.................... 
.................... #ifdef _STRING
.................... void get_stringEdit(char* s, unsigned int8 max) {
....................    unsigned int8 len;
....................    char c;
.................... 
....................    len = strlen(s);
.................... 
....................    if (len)
....................    {
....................      #if defined(STREAM_SERIAL_INPUT)
....................       fprintf(STREAM_SERIAL_INPUT, "%s", s);
....................      #else
....................       printf(InputPutc, "%s", s);
....................      #endif
....................    }
.................... 
....................    max-=2;
.................... 
....................    do {
....................      c=InputGetc();
....................      if(c==8) {  // Backspace
....................         if(len>0) {
....................           len--;
....................           InputPutc(c);
....................           InputPutc(' ');
....................           InputPutc(c);
....................         }
....................      } else if ((c>=' ')&&(c<='~'))
....................        if(len<=max) {
....................          s[len++]=c;
....................          InputPutc(c);
....................        }
....................    } while(c!=13);
....................    s[len]=0;
.................... }
.................... #endif
.................... 
.................... // stdlib.h is required for the ato_ conversions
.................... // in the following functions
.................... #ifdef _STDLIB
.................... signed int8 get_Int8(void)
.................... {
....................   char s[5];
....................   signed int8 i;
.................... 
....................   get_string(s, sizeof(s));
.................... 
....................   i=atoi(s);
....................   return(i);
.................... }
.................... 
.................... #ifdef _STRING
.................... signed int8 get_Int8Edit(signed int8 old)
.................... {
....................   char s[5];
....................   signed int8 i;
.................... 
....................   sprintf(s, "%d", old);
....................   get_stringEdit(s, sizeof(s));
.................... 
....................   i=atoi(s);
....................   return(i);
.................... }
.................... #endif
.................... 
.................... signed int16 get_Int16(void)
.................... {
....................   char s[7];
....................   signed int16 l;
.................... 
....................   get_string(s, sizeof(s));
....................   l=atol(s);
....................   return(l);
.................... }
.................... 
.................... #ifdef _STRING
.................... signed int16 get_Int16Edit(signed int16 old)
.................... {
....................   char s[7];
....................   signed int16 l;
.................... 
....................   sprintf(s, "%ld", old);
.................... 
....................   get_stringEdit(s, sizeof(s));
....................   l=atol(s);
....................   return(l);
.................... }
.................... #endif
.................... 
.................... signed int32 get_Int32(void)
.................... {
....................   char s[12];
....................   signed int32 l;
.................... 
....................   get_string(s, sizeof(s));
....................   l=atoi32(s);
....................   return(l);
.................... }
.................... 
.................... #ifdef _STRING
.................... signed int32 get_Int32Edit(signed int32 old)
.................... {
....................   char s[12];
....................   signed int32 l;
.................... 
....................   sprintf(s, "%ld", old);
.................... 
....................   get_stringEdit(s, sizeof(s));
....................   l=atoi32(s);
....................   return(l);
.................... }
.................... #endif
.................... 
.................... float get_float() {
....................   char s[20];
....................   float f;
.................... 
....................   get_string(s, 20);
....................   f = atof(s);
....................   return(f);
.................... }
.................... 
.................... #ifdef _STRING
.................... float get_floatEdit(float old) {
....................   char s[20];
....................   float f;
.................... 
....................   sprintf(s, "%f", old);
.................... 
....................   get_string(s, 20);
....................   f = atof(s);
....................   return(f);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
....................    #define get_int()       get_Int16()
....................    #define get_intEdit()   get_Int16Edit()
....................    #define get_long()      get_Int32()
....................    #define get_longEdit()  get_Int32Edit()
.................... #else
....................    #define get_int()       get_Int8()
....................    #define get_intEdit()   get_Int8Edit()
....................    #define get_long()      get_Int16()
....................    #define get_longEdit()  get_Int16Edit()
.................... #endif
.................... 
.................... #endif   //_STDLIB
.................... 
.................... #endif   //__INPUT_C__
.................... 
.................... #include <STDLIB.H>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
00D98:  MOVFF  88,8B
....................    for(su=s;0<n;++su,--n)
00D9C:  MOVFF  87,8D
00DA0:  MOVFF  86,8C
00DA4:  MOVF   x8A,F
00DA6:  BNZ   0DAE
00DA8:  MOVF   x89,W
00DAA:  SUBLW  00
00DAC:  BC    0DDA
....................       if(*su==uc)
00DAE:  MOVFF  8D,03
00DB2:  MOVFF  8C,FE9
00DB6:  MOVFF  8D,FEA
00DBA:  MOVF   x8B,W
00DBC:  SUBWF  FEF,W
00DBE:  BNZ   0DCA
....................       return su;
00DC0:  MOVFF  8C,01
00DC4:  MOVFF  8D,02
00DC8:  BRA    0DE0
00DCA:  INCF   x8C,F
00DCC:  BTFSC  FD8.2
00DCE:  INCF   x8D,F
00DD0:  MOVF   x89,W
00DD2:  BTFSC  FD8.2
00DD4:  DECF   x8A,F
00DD6:  DECF   x89,F
00DD8:  BRA    0DA4
....................    return NULL;
00DDA:  MOVLW  00
00DDC:  MOVWF  01
00DDE:  MOVWF  02
00DE0:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
....................    goto StrtoulGO;
.................... 
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(; sd!=0; )
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtoulGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
....................    }
....................    if (endptr)
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
*
00E34:  CLRF   5F
00E36:  CLRF   5E
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
00E38:  MOVLW  30
00E3A:  MOVWF  x61
00E3C:  MOVLW  31
00E3E:  MOVWF  x62
00E40:  MOVLW  32
00E42:  MOVWF  x63
00E44:  MOVLW  33
00E46:  MOVWF  x64
00E48:  MOVLW  34
00E4A:  MOVWF  x65
00E4C:  MOVLW  35
00E4E:  MOVWF  x66
00E50:  MOVLW  36
00E52:  MOVWF  x67
00E54:  MOVLW  37
00E56:  MOVWF  x68
00E58:  MOVLW  38
00E5A:  MOVWF  x69
00E5C:  MOVLW  39
00E5E:  MOVWF  x6A
00E60:  MOVLW  61
00E62:  MOVWF  x6B
00E64:  MOVLW  62
00E66:  MOVWF  x6C
00E68:  MOVLW  63
00E6A:  MOVWF  x6D
00E6C:  MOVLW  64
00E6E:  MOVWF  x6E
00E70:  MOVLW  65
00E72:  MOVWF  x6F
00E74:  MOVLW  66
00E76:  MOVWF  x70
00E78:  MOVLW  67
00E7A:  MOVWF  x71
00E7C:  MOVLW  68
00E7E:  MOVWF  x72
00E80:  MOVLW  69
00E82:  MOVWF  x73
00E84:  MOVLW  6A
00E86:  MOVWF  x74
00E88:  MOVLW  6B
00E8A:  MOVWF  x75
00E8C:  MOVLW  6C
00E8E:  MOVWF  x76
00E90:  MOVLW  6D
00E92:  MOVWF  x77
00E94:  MOVLW  6E
00E96:  MOVWF  x78
00E98:  MOVLW  6F
00E9A:  MOVWF  x79
00E9C:  MOVLW  70
00E9E:  MOVWF  x7A
00EA0:  MOVLW  71
00EA2:  MOVWF  x7B
00EA4:  MOVLW  73
00EA6:  MOVWF  x7C
00EA8:  MOVLW  74
00EAA:  MOVWF  x7D
00EAC:  MOVLW  75
00EAE:  MOVWF  x7E
00EB0:  MOVLW  76
00EB2:  MOVWF  x7F
00EB4:  MOVLW  77
00EB6:  MOVWF  x80
00EB8:  MOVLW  78
00EBA:  MOVWF  x81
00EBC:  MOVLW  79
00EBE:  MOVWF  x82
00EC0:  MOVLW  7A
00EC2:  MOVWF  x83
00EC4:  CLRF   x84
....................    for(sc=s;isspace(*sc);++sc);
00EC6:  MOVFF  54,59
00ECA:  MOVFF  53,58
00ECE:  MOVFF  59,03
00ED2:  MOVFF  58,FE9
00ED6:  MOVFF  59,FEA
00EDA:  MOVF   FEF,W
00EDC:  SUBLW  20
00EDE:  BNZ   0EE8
00EE0:  INCF   58,F
00EE2:  BTFSC  FD8.2
00EE4:  INCF   59,F
00EE6:  BRA    0ECE
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
00EE8:  MOVFF  59,03
00EEC:  MOVFF  58,FE9
00EF0:  MOVFF  59,FEA
00EF4:  MOVF   FEF,W
00EF6:  SUBLW  2D
00EF8:  BZ    0F0C
00EFA:  MOVFF  59,03
00EFE:  MOVFF  58,FE9
00F02:  MOVFF  59,FEA
00F06:  MOVF   FEF,W
00F08:  SUBLW  2B
00F0A:  BNZ   0F1E
00F0C:  MOVFF  59,FEA
00F10:  MOVF   58,W
00F12:  INCF   58,F
00F14:  BTFSC  FD8.2
00F16:  INCF   59,F
00F18:  MOVWF  FE9
00F1A:  MOVF   FEF,W
00F1C:  BRA    0F20
00F1E:  MOVLW  2B
00F20:  MOVWF  x60
....................    if (base <0 || base ==1|| base >36) // invalid base
00F22:  BTFSC  57.7
00F24:  BRA    0F36
00F26:  DECFSZ 57,W
00F28:  BRA    0F2C
00F2A:  BRA    0F36
00F2C:  BTFSC  57.7
00F2E:  BRA    0F3A
00F30:  MOVF   57,W
00F32:  SUBLW  24
00F34:  BC    0F3A
....................    goto StrtolGO;
00F36:  BRA    1140
00F38:  BRA    1042
....................    else if (base)
00F3A:  MOVF   57,F
00F3C:  BZ    0FD6
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
00F3E:  MOVF   57,W
00F40:  SUBLW  10
00F42:  BNZ   0F82
00F44:  MOVFF  59,03
00F48:  MOVFF  58,FE9
00F4C:  MOVFF  59,FEA
00F50:  MOVF   FEF,W
00F52:  SUBLW  30
00F54:  BNZ   0F82
00F56:  MOVLW  01
00F58:  ADDWF  58,W
00F5A:  MOVWF  FE9
00F5C:  MOVLW  00
00F5E:  ADDWFC 59,W
00F60:  MOVWF  FEA
00F62:  MOVF   FEF,W
00F64:  SUBLW  78
00F66:  BZ    0F7A
00F68:  MOVLW  01
00F6A:  ADDWF  58,W
00F6C:  MOVWF  FE9
00F6E:  MOVLW  00
00F70:  ADDWFC 59,W
00F72:  MOVWF  FEA
00F74:  MOVF   FEF,W
00F76:  SUBLW  58
00F78:  BNZ   0F82
....................          sc+=2;
00F7A:  MOVLW  02
00F7C:  ADDWF  58,F
00F7E:  MOVLW  00
00F80:  ADDWFC 59,F
....................       if(base==8 && *sc =='0')
00F82:  MOVF   57,W
00F84:  SUBLW  08
00F86:  BNZ   0FA2
00F88:  MOVFF  59,03
00F8C:  MOVFF  58,FE9
00F90:  MOVFF  59,FEA
00F94:  MOVF   FEF,W
00F96:  SUBLW  30
00F98:  BNZ   0FA2
....................          sc+=1;
00F9A:  MOVLW  01
00F9C:  ADDWF  58,F
00F9E:  MOVLW  00
00FA0:  ADDWFC 59,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
00FA2:  MOVF   57,W
00FA4:  SUBLW  02
00FA6:  BNZ   0FD4
00FA8:  MOVFF  59,03
00FAC:  MOVFF  58,FE9
00FB0:  MOVFF  59,FEA
00FB4:  MOVF   FEF,W
00FB6:  SUBLW  30
00FB8:  BNZ   0FD4
00FBA:  MOVLW  01
00FBC:  ADDWF  58,W
00FBE:  MOVWF  FE9
00FC0:  MOVLW  00
00FC2:  ADDWFC 59,W
00FC4:  MOVWF  FEA
00FC6:  MOVF   FEF,W
00FC8:  SUBLW  62
00FCA:  BNZ   0FD4
....................          sc+=2;
00FCC:  MOVLW  02
00FCE:  ADDWF  58,F
00FD0:  MOVLW  00
00FD2:  ADDWFC 59,F
.................... 
....................    }
00FD4:  BRA    1042
....................    else if(*sc!='0') // base is 0, find base
00FD6:  MOVFF  59,03
00FDA:  MOVFF  58,FE9
00FDE:  MOVFF  59,FEA
00FE2:  MOVF   FEF,W
00FE4:  SUBLW  30
00FE6:  BZ    0FEE
....................       base=10;
00FE8:  MOVLW  0A
00FEA:  MOVWF  57
00FEC:  BRA    1042
....................    else if (sc[1]=='x' || sc[1]=='X')
00FEE:  MOVLW  01
00FF0:  ADDWF  58,W
00FF2:  MOVWF  FE9
00FF4:  MOVLW  00
00FF6:  ADDWFC 59,W
00FF8:  MOVWF  FEA
00FFA:  MOVF   FEF,W
00FFC:  SUBLW  78
00FFE:  BZ    1012
01000:  MOVLW  01
01002:  ADDWF  58,W
01004:  MOVWF  FE9
01006:  MOVLW  00
01008:  ADDWFC 59,W
0100A:  MOVWF  FEA
0100C:  MOVF   FEF,W
0100E:  SUBLW  58
01010:  BNZ   1020
....................       base =16,sc+=2;
01012:  MOVLW  10
01014:  MOVWF  57
01016:  MOVLW  02
01018:  ADDWF  58,F
0101A:  MOVLW  00
0101C:  ADDWFC 59,F
0101E:  BRA    1042
....................    else if(sc[1]=='b')
01020:  MOVLW  01
01022:  ADDWF  58,W
01024:  MOVWF  FE9
01026:  MOVLW  00
01028:  ADDWFC 59,W
0102A:  MOVWF  FEA
0102C:  MOVF   FEF,W
0102E:  SUBLW  62
01030:  BNZ   103E
....................       base=2,sc+=2;
01032:  MOVLW  02
01034:  MOVWF  57
01036:  ADDWF  58,F
01038:  MOVLW  00
0103A:  ADDWFC 59,F
0103C:  BRA    1042
....................    else
....................       base=8;
0103E:  MOVLW  08
01040:  MOVWF  57
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
01042:  MOVFF  59,5B
01046:  MOVFF  58,5A
0104A:  MOVFF  59,03
0104E:  MOVFF  58,FE9
01052:  MOVFF  59,FEA
01056:  MOVF   FEF,W
01058:  SUBLW  30
0105A:  BNZ   1064
0105C:  INCF   58,F
0105E:  BTFSC  FD8.2
01060:  INCF   59,F
01062:  BRA    104A
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
01064:  MOVFF  59,03
01068:  MOVFF  58,FE9
0106C:  MOVFF  59,FEA
01070:  MOVFF  FEF,85
01074:  MOVF   x85,W
01076:  SUBLW  40
01078:  BC    1086
0107A:  MOVF   x85,W
0107C:  SUBLW  5A
0107E:  BNC   1086
01080:  MOVF   x85,W
01082:  IORLW  20
01084:  BRA    1088
01086:  MOVF   x85,W
01088:  MOVWF  x85
0108A:  CLRF   x87
0108C:  MOVLW  61
0108E:  MOVWF  x86
01090:  MOVFF  85,88
01094:  CLRF   x8A
01096:  MOVFF  57,89
0109A:  BTFSC  x89.7
0109C:  DECF   x8A,F
0109E:  RCALL  0D98
010A0:  MOVFF  02,5D
010A4:  MOVFF  01,5C
....................    for(;sd!=0;)
010A8:  MOVF   5C,F
010AA:  BNZ   10B0
010AC:  MOVF   5D,F
010AE:  BZ    1134
....................    {
....................       x=x*base+(int16)(sd-digits);
010B0:  CLRF   03
010B2:  MOVF   57,W
010B4:  MOVWF  00
010B6:  BTFSC  FE8.7
010B8:  DECF   03,F
010BA:  MOVWF  x85
010BC:  MOVFF  03,86
010C0:  MOVFF  5F,88
010C4:  MOVFF  5E,87
010C8:  MOVFF  03,8A
010CC:  MOVWF  x89
010CE:  BRA    0DE2
010D0:  MOVLW  61
010D2:  SUBWF  5C,W
010D4:  MOVWF  00
010D6:  MOVLW  00
010D8:  SUBWFB 5D,W
010DA:  MOVWF  03
010DC:  MOVF   00,W
010DE:  ADDWF  01,W
010E0:  MOVWF  5E
010E2:  MOVF   03,W
010E4:  ADDWFC 02,W
010E6:  MOVWF  5F
....................       ++sc;
010E8:  INCF   58,F
010EA:  BTFSC  FD8.2
010EC:  INCF   59,F
....................       sd=memchr(digits,tolower(*sc),base);
010EE:  MOVFF  59,03
010F2:  MOVFF  58,FE9
010F6:  MOVFF  59,FEA
010FA:  MOVFF  FEF,85
010FE:  MOVF   x85,W
01100:  SUBLW  40
01102:  BC    1110
01104:  MOVF   x85,W
01106:  SUBLW  5A
01108:  BNC   1110
0110A:  MOVF   x85,W
0110C:  IORLW  20
0110E:  BRA    1112
01110:  MOVF   x85,W
01112:  MOVWF  x85
01114:  CLRF   x87
01116:  MOVLW  61
01118:  MOVWF  x86
0111A:  MOVFF  85,88
0111E:  CLRF   x8A
01120:  MOVFF  57,89
01124:  BTFSC  x89.7
01126:  DECF   x8A,F
01128:  RCALL  0D98
0112A:  MOVFF  02,5D
0112E:  MOVFF  01,5C
01132:  BRA    10A8
....................    }
....................    if(s1==sc)
01134:  MOVF   58,W
01136:  SUBWF  5A,W
01138:  BNZ   1162
0113A:  MOVF   59,W
0113C:  SUBWF  5B,W
0113E:  BNZ   1162
....................    {
....................    StrtolGO:
....................       if (endptr)
01140:  MOVF   55,W
01142:  IORWF  56,W
01144:  BZ    1158
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
01146:  MOVFF  55,FE9
0114A:  MOVFF  56,FEA
0114E:  MOVFF  54,FEC
01152:  MOVF   FED,F
01154:  MOVFF  53,FEF
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
01158:  MOVLW  00
0115A:  MOVWF  01
0115C:  MOVWF  02
0115E:  BRA    1192
01160:  MOVLB  0
....................    }
....................    if(sign=='-')
01162:  MOVF   x60,W
01164:  SUBLW  2D
01166:  BNZ   1172
....................       x  =-x;
01168:  COMF   5E,F
0116A:  COMF   5F,F
0116C:  INCF   5E,F
0116E:  BTFSC  FD8.2
01170:  INCF   5F,F
....................    if (endptr)
01172:  MOVF   55,W
01174:  IORWF  56,W
01176:  BZ    118A
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
01178:  MOVFF  55,FE9
0117C:  MOVFF  56,FEA
01180:  MOVFF  59,FEC
01184:  MOVF   FED,F
01186:  MOVFF  58,FEF
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
0118A:  MOVFF  5E,01
0118E:  MOVFF  5F,02
01192:  MOVLB  0
01194:  GOTO   1356 (RETURN)
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include <lcd.c>
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ////                             LCD.C                                     ////
.................... ////                 Driver for common LCD modules                         ////
.................... ////                                                                       ////
.................... ////  lcd_init()   Must be called before any other function.               ////
.................... ////                                                                       ////
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         ////
.................... ////                 \a  Set cursor position to upper left                 ////
.................... ////                 \f  Clear display, set cursor to upper left           ////
.................... ////                 \n  Go to start of second line                        ////
.................... ////                 \b  Move back one position                            ////
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     ////
.................... ////              will erase all remanining characters on the current      ////
.................... ////              line, and move the cursor to the beginning of the next   ////
.................... ////              line.                                                    ////
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     ////
.................... ////              will move the cursor to the start of the current         ////
.................... ////              line.                                                    ////
.................... ////                                                                       ////
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        ////
.................... ////                                                                       ////
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             ////
.................... ////                                                                       ////
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         ////
.................... ////              (on=FALSE).                                              ////
.................... ////                                                                       ////
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   ////
.................... ////                                                                       ////
.................... ////                                                                       ////
.................... ////  CONFIGURATION                                                        ////
.................... ////  The LCD can be configured in one of two ways: a.) port access or     ////
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     ////
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     ////
.................... ////  connected to sequential pins on the GPIO.  Pin access                ////
.................... ////  has no requirements, all 7 bits of the control interface can         ////
.................... ////  can be connected to any GPIO using several ports.                    ////
.................... ////                                                                       ////
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     ////
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    ////
.................... ////  of this file to configure the pin order.  If you are using a         ////
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  ////
.................... ////  be defined.                                                          ////
.................... ////                                                                       ////
.................... ////  Example of port access:                                              ////
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         ////
.................... ////                                                                       ////
.................... ////  To use pin access, the following pins must be defined:               ////
.................... ////     LCD_ENABLE_PIN                                                    ////
.................... ////     LCD_RS_PIN                                                        ////
.................... ////     LCD_RW_PIN                                                        ////
.................... ////     LCD_DATA4                                                         ////
.................... ////     LCD_DATA5                                                         ////
.................... ////     LCD_DATA6                                                         ////
.................... ////     LCD_DATA7                                                         ////
.................... ////                                                                       ////
.................... ////  Example of pin access:                                               ////
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    ////
.................... ////     #define LCD_RS_PIN      PIN_E1                                    ////
.................... ////     #define LCD_RW_PIN      PIN_E2                                    ////
.................... ////     #define LCD_DATA4       PIN_D4                                    ////
.................... ////     #define LCD_DATA5       PIN_D5                                    ////
.................... ////     #define LCD_DATA6       PIN_D6                                    ////
.................... ////     #define LCD_DATA7       PIN_D7                                    ////
.................... ////                                                                       ////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __LCD_C__
.................... #define __LCD_C__
.................... 
.................... // define the pinout.
.................... // only required if port access is being used.
.................... typedef struct  
.................... {                            // This structure is overlayed
....................    int1 enable;           // on to an I/O port to gain
....................    int1 rs;               // access to the LCD pins.
....................    int1 rw;               // The bits are allocated from
....................    int1 unused;           // low order up.  ENABLE will
....................    unsigned int     data : 4;         // be LSB pin of that port.
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT.
....................    unsigned int    reserved: 8;
....................   #endif
.................... } LCD_PIN_MAP;
.................... 
.................... // this is to improve compatability with previous LCD drivers that accepted
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B.
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE))
....................  #define LCD_DATA_PORT getenv("SFR:PORTB")
.................... #endif
.................... 
.................... #if defined(__PCB__)
....................    // these definitions only need to be modified for baseline PICs.
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions.
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0};
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF};
.................... #endif
.................... 
.................... ////////////////////// END CONFIGURATION ///////////////////////////////////
.................... 
.................... #ifndef LCD_ENABLE_PIN
....................    #define lcd_output_enable(x) lcdlat.enable=x
....................    #define lcd_enable_tris()   lcdtris.enable=0
.................... #else
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x)
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN)
.................... #endif
.................... 
.................... #ifndef LCD_RS_PIN
....................    #define lcd_output_rs(x) lcdlat.rs=x
....................    #define lcd_rs_tris()   lcdtris.rs=0
.................... #else
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x)
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN)
.................... #endif
.................... 
.................... #ifndef LCD_RW_PIN
....................    #define lcd_output_rw(x) lcdlat.rw=x
....................    #define lcd_rw_tris()   lcdtris.rw=0
.................... #else
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x)
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN)
.................... #endif
.................... 
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4,
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver
.................... // compatible with any code written for the original library
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7))
....................    #define  LCD_DATA4    LCD_DATA0
....................    #define  LCD_DATA5    LCD_DATA1
....................    #define  LCD_DATA6    LCD_DATA2
....................    #define  LCD_DATA7    LCD_DATA3
.................... #endif
.................... 
.................... #ifndef LCD_DATA4
.................... #ifndef LCD_DATA_PORT
....................    #if defined(__PCB__)
....................       #define LCD_DATA_PORT      0x06     //portb
....................       #define set_tris_lcd(x)   set_tris_b(x)
....................    #else
....................      #if defined(PIN_D0)
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd
....................      #else
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb
....................      #endif
....................    #endif   
.................... #endif
.................... 
.................... #if defined(__PCB__)
....................    LCD_PIN_MAP lcd, lcdlat;
....................    #byte lcd = LCD_DATA_PORT
....................    #byte lcdlat = LCD_DATA_PORT
.................... #elif defined(__PCM__)
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris;
....................    #byte lcd = LCD_DATA_PORT
....................    #byte lcdlat = LCD_DATA_PORT
....................    #byte lcdtris = LCD_DATA_PORT+0x80
.................... #elif defined(__PCH__)
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris;
....................    #byte lcd = LCD_DATA_PORT
....................    #byte lcdlat = LCD_DATA_PORT+9
....................    #byte lcdtris = LCD_DATA_PORT+0x12
.................... #elif defined(__PCD__)
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris;
....................    #word lcd = LCD_DATA_PORT
....................    #word lcdlat = LCD_DATA_PORT+2
....................    #word lcdtris = LCD_DATA_PORT-0x02
.................... #endif
.................... #endif   //LCD_DATA4 not defined
.................... 
.................... #ifndef LCD_TYPE
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines
.................... #endif
.................... 
.................... #ifndef LCD_LINE_TWO
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line
.................... #endif
.................... 
.................... #ifndef LCD_LINE_LENGTH
....................    #define LCD_LINE_LENGTH 20
.................... #endif
.................... 
.................... unsigned int8 lcd_read_nibble(void);
.................... 
.................... unsigned int8 lcd_read_byte(void)
.................... {
....................    unsigned int8 low,high;
.................... 
....................  #if defined(__PCB__)
....................    set_tris_lcd(LCD_INPUT_MAP);
....................  #else
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    output_float(LCD_DATA4);
*
00382:  BSF    F95.4
....................    output_float(LCD_DATA5);
00384:  BSF    F95.5
....................    output_float(LCD_DATA6);
00386:  BSF    F95.6
....................    output_float(LCD_DATA7);
00388:  BSF    F95.7
....................   #else
....................    lcdtris.data = 0xF;
....................   #endif
....................  #endif
....................         
....................    lcd_output_rw(1);
0038A:  BSF    F8D.2
0038C:  BCF    F96.2
....................    delay_cycles(1);
0038E:  NOP   
....................    lcd_output_enable(1);
00390:  BSF    F8D.1
00392:  BCF    F96.1
....................    delay_cycles(1);
00394:  NOP   
....................    high = lcd_read_nibble();
00396:  RCALL  0330
00398:  MOVFF  01,A4
....................       
....................    lcd_output_enable(0);
0039C:  BCF    F8D.1
0039E:  BCF    F96.1
....................    delay_cycles(1);
003A0:  NOP   
....................    lcd_output_enable(1);
003A2:  BSF    F8D.1
003A4:  BCF    F96.1
....................    delay_us(1);
003A6:  BRA    03A8
....................    low = lcd_read_nibble();
003A8:  RCALL  0330
003AA:  MOVFF  01,A3
....................       
....................    lcd_output_enable(0);
003AE:  BCF    F8D.1
003B0:  BCF    F96.1
.................... 
....................  #if defined(__PCB__)
....................    set_tris_lcd(LCD_OUTPUT_MAP);
....................  #else
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    output_drive(LCD_DATA4);
003B2:  BCF    F95.4
....................    output_drive(LCD_DATA5);
003B4:  BCF    F95.5
....................    output_drive(LCD_DATA6);
003B6:  BCF    F95.6
....................    output_drive(LCD_DATA7);
003B8:  BCF    F95.7
....................   #else
....................    lcdtris.data = 0x0;
....................   #endif
....................  #endif
.................... 
....................    return( (high<<4) | low);
003BA:  SWAPF  xA4,W
003BC:  MOVWF  00
003BE:  MOVLW  F0
003C0:  ANDWF  00,F
003C2:  MOVF   00,W
003C4:  IORWF  xA3,W
003C6:  MOVWF  01
003C8:  RETURN 0
.................... }
.................... 
.................... unsigned int8 lcd_read_nibble(void)
.................... {
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
*
00330:  CLRF   xA5
....................    unsigned int8 n = 0x00;
.................... 
....................    /* Read the data port */
....................    n |= input(LCD_DATA4);
00332:  BSF    F95.4
00334:  MOVLW  00
00336:  BTFSC  F83.4
00338:  MOVLW  01
0033A:  IORWF  xA5,F
....................    n |= input(LCD_DATA5) << 1;
0033C:  BSF    F95.5
0033E:  MOVLW  00
00340:  BTFSC  F83.5
00342:  MOVLW  01
00344:  MOVWF  00
00346:  BCF    FD8.0
00348:  RLCF   00,F
0034A:  MOVF   00,W
0034C:  IORWF  xA5,F
....................    n |= input(LCD_DATA6) << 2;
0034E:  BSF    F95.6
00350:  MOVLW  00
00352:  BTFSC  F83.6
00354:  MOVLW  01
00356:  MOVWF  00
00358:  RLCF   00,F
0035A:  RLCF   00,F
0035C:  MOVLW  FC
0035E:  ANDWF  00,F
00360:  MOVF   00,W
00362:  IORWF  xA5,F
....................    n |= input(LCD_DATA7) << 3;
00364:  BSF    F95.7
00366:  MOVLW  00
00368:  BTFSC  F83.7
0036A:  MOVLW  01
0036C:  MOVWF  00
0036E:  RLCF   00,F
00370:  RLCF   00,F
00372:  RLCF   00,F
00374:  MOVLW  F8
00376:  ANDWF  00,F
00378:  MOVF   00,W
0037A:  IORWF  xA5,F
....................    
....................    return(n);
0037C:  MOVFF  A5,01
....................   #else
00380:  RETURN 0
....................    return(lcd.data);
....................   #endif
.................... }
.................... 
.................... void lcd_send_nibble(unsigned int8 n)
.................... {
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    /* Write to the data port */
....................    output_bit(LCD_DATA4, bit_test(n, 0));
*
003CA:  BTFSC  xA4.0
003CC:  BRA    03D2
003CE:  BCF    F8C.4
003D0:  BRA    03D4
003D2:  BSF    F8C.4
003D4:  BCF    F95.4
....................    output_bit(LCD_DATA5, bit_test(n, 1));
003D6:  BTFSC  xA4.1
003D8:  BRA    03DE
003DA:  BCF    F8C.5
003DC:  BRA    03E0
003DE:  BSF    F8C.5
003E0:  BCF    F95.5
....................    output_bit(LCD_DATA6, bit_test(n, 2));
003E2:  BTFSC  xA4.2
003E4:  BRA    03EA
003E6:  BCF    F8C.6
003E8:  BRA    03EC
003EA:  BSF    F8C.6
003EC:  BCF    F95.6
....................    output_bit(LCD_DATA7, bit_test(n, 3));
003EE:  BTFSC  xA4.3
003F0:  BRA    03F6
003F2:  BCF    F8C.7
003F4:  BRA    03F8
003F6:  BSF    F8C.7
003F8:  BCF    F95.7
....................   #else      
....................    lcdlat.data = n;
....................   #endif
....................       
....................    delay_cycles(1);
003FA:  NOP   
....................    lcd_output_enable(1);
003FC:  BSF    F8D.1
003FE:  BCF    F96.1
....................    delay_us(2);
00400:  BRA    0402
00402:  BRA    0404
....................    lcd_output_enable(0);
00404:  BCF    F8D.1
00406:  BCF    F96.1
00408:  RETURN 0
.................... }
.................... 
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n)
.................... {
....................   #if defined(__PCB__)
....................    set_tris_lcd(LCD_OUTPUT_MAP);
....................   #else
....................    lcd_enable_tris();
0040A:  BCF    F96.1
....................    lcd_rs_tris();
0040C:  BCF    F96.0
....................    lcd_rw_tris();
0040E:  BCF    F96.2
....................   #endif
.................... 
....................    lcd_output_rs(0);
00410:  BCF    F8D.0
00412:  BCF    F96.0
....................    while ( bit_test(lcd_read_byte(),7) ) ;
00414:  RCALL  0382
00416:  MOVFF  01,A3
0041A:  BTFSC  01.7
0041C:  BRA    0414
....................    lcd_output_rs(address);
0041E:  MOVF   xA1,F
00420:  BNZ   0426
00422:  BCF    F8D.0
00424:  BRA    0428
00426:  BSF    F8D.0
00428:  BCF    F96.0
....................    delay_cycles(1);
0042A:  NOP   
....................    lcd_output_rw(0);
0042C:  BCF    F8D.2
0042E:  BCF    F96.2
....................    delay_cycles(1);
00430:  NOP   
....................    lcd_output_enable(0);
00432:  BCF    F8D.1
00434:  BCF    F96.1
....................    lcd_send_nibble(n >> 4);
00436:  SWAPF  xA2,W
00438:  MOVWF  xA3
0043A:  MOVLW  0F
0043C:  ANDWF  xA3,F
0043E:  MOVFF  A3,A4
00442:  RCALL  03CA
....................    lcd_send_nibble(n & 0xf);
00444:  MOVF   xA2,W
00446:  ANDLW  0F
00448:  MOVWF  xA3
0044A:  MOVWF  xA4
0044C:  RCALL  03CA
0044E:  RETURN 0
.................... }
.................... 
.................... #if defined(LCD_EXTENDED_NEWLINE)
.................... unsigned int8 g_LcdX, g_LcdY;
.................... #endif
.................... 
.................... void lcd_init(void) 
.................... {
....................    unsigned int8 i;
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6};
*
00BFE:  MOVLW  28
00C00:  MOVWF  54
00C02:  MOVLW  0C
00C04:  MOVWF  55
00C06:  MOVLW  01
00C08:  MOVWF  56
00C0A:  MOVLW  06
00C0C:  MOVWF  57
....................                              // These bytes need to be sent to the LCD
....................                              // to start it up.
....................    
.................... 
....................    lcd_output_enable(0);
00C0E:  BCF    F8D.1
00C10:  BCF    F96.1
....................    lcd_output_rs(0);
00C12:  BCF    F8D.0
00C14:  BCF    F96.0
....................    lcd_output_rw(0);
00C16:  BCF    F8D.2
00C18:  BCF    F96.2
.................... 
....................  #if defined(__PCB__)
....................    set_tris_lcd(LCD_OUTPUT_MAP);
....................  #else
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    output_drive(LCD_DATA4);
00C1A:  BCF    F95.4
....................    output_drive(LCD_DATA5);
00C1C:  BCF    F95.5
....................    output_drive(LCD_DATA6);
00C1E:  BCF    F95.6
....................    output_drive(LCD_DATA7);
00C20:  BCF    F95.7
....................   #else
....................    lcdtris.data = 0x0;
....................   #endif
....................    lcd_enable_tris();
00C22:  BCF    F96.1
....................    lcd_rs_tris();
00C24:  BCF    F96.0
....................    lcd_rw_tris();
00C26:  BCF    F96.2
00C28:  CLRF   19
00C2A:  BTFSC  FF2.7
00C2C:  BSF    19.7
00C2E:  BCF    FF2.7
....................  #endif
....................     
....................    delay_ms(15);
00C30:  MOVLW  0F
00C32:  MOVWF  x9D
00C34:  RCALL  0540
00C36:  BTFSC  19.7
00C38:  BSF    FF2.7
....................    for(i=1;i<=3;++i)
00C3A:  MOVLW  01
00C3C:  MOVWF  53
00C3E:  MOVF   53,W
00C40:  SUBLW  03
00C42:  BNC   0C6E
00C44:  CLRF   19
00C46:  BTFSC  FF2.7
00C48:  BSF    19.7
00C4A:  BCF    FF2.7
....................    {
....................        lcd_send_nibble(3);
00C4C:  MOVLW  03
00C4E:  MOVWF  xA4
00C50:  CALL   03CA
00C54:  BTFSC  19.7
00C56:  BSF    FF2.7
00C58:  CLRF   19
00C5A:  BTFSC  FF2.7
00C5C:  BSF    19.7
00C5E:  BCF    FF2.7
....................        delay_ms(5);
00C60:  MOVLW  05
00C62:  MOVWF  x9D
00C64:  RCALL  0540
00C66:  BTFSC  19.7
00C68:  BSF    FF2.7
00C6A:  INCF   53,F
00C6C:  BRA    0C3E
00C6E:  CLRF   19
00C70:  BTFSC  FF2.7
00C72:  BSF    19.7
00C74:  BCF    FF2.7
....................    }
....................    
....................    lcd_send_nibble(2);
00C76:  MOVLW  02
00C78:  MOVWF  xA4
00C7A:  CALL   03CA
00C7E:  BTFSC  19.7
00C80:  BSF    FF2.7
00C82:  CLRF   19
00C84:  BTFSC  FF2.7
00C86:  BSF    19.7
00C88:  BCF    FF2.7
....................    delay_ms(5);
00C8A:  MOVLW  05
00C8C:  MOVWF  x9D
00C8E:  RCALL  0540
00C90:  BTFSC  19.7
00C92:  BSF    FF2.7
....................    for(i=0;i<=3;++i)
00C94:  CLRF   53
00C96:  MOVF   53,W
00C98:  SUBLW  03
00C9A:  BNC   0CC4
....................       lcd_send_byte(0,LCD_INIT_STRING[i]);
00C9C:  CLRF   03
00C9E:  MOVF   53,W
00CA0:  ADDLW  54
00CA2:  MOVWF  FE9
00CA4:  MOVLW  00
00CA6:  ADDWFC 03,W
00CA8:  MOVWF  FEA
00CAA:  CLRF   19
00CAC:  BTFSC  FF2.7
00CAE:  BSF    19.7
00CB0:  BCF    FF2.7
00CB2:  MOVFF  FEF,A2
00CB6:  CLRF   xA1
00CB8:  CALL   040A
00CBC:  BTFSC  19.7
00CBE:  BSF    FF2.7
.................... 
....................   #if defined(LCD_EXTENDED_NEWLINE)
00CC0:  INCF   53,F
00CC2:  BRA    0C96
00CC4:  GOTO   12F8 (RETURN)
....................    g_LcdX = 0;
....................    g_LcdY = 0;
....................   #endif
.................... }
.................... 
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y)
.................... {
....................    unsigned int8 address;
....................    
....................    if(y!=1)
*
00450:  DECFSZ x9E,W
00452:  BRA    0456
00454:  BRA    045C
....................       address=LCD_LINE_TWO;
00456:  MOVLW  40
00458:  MOVWF  x9F
0045A:  BRA    045E
....................    else
....................       address=0;
0045C:  CLRF   x9F
....................      
....................    address+=x-1;
0045E:  MOVLW  01
00460:  SUBWF  x9D,W
00462:  ADDWF  x9F,F
....................    lcd_send_byte(0,0x80|address);
00464:  MOVF   x9F,W
00466:  IORLW  80
00468:  MOVWF  xA0
0046A:  CLRF   xA1
0046C:  MOVWF  xA2
0046E:  RCALL  040A
.................... 
....................   #if defined(LCD_EXTENDED_NEWLINE)
00470:  RETURN 0
....................    g_LcdX = x - 1;
....................    g_LcdY = y - 1;
....................   #endif
.................... }
.................... 
.................... void lcd_putc(char c)
.................... {
....................    switch (c)
*
00566:  MOVF   x9C,W
00568:  XORLW  07
0056A:  BZ    057A
0056C:  XORLW  0B
0056E:  BZ    0584
00570:  XORLW  06
00572:  BZ    0594
00574:  XORLW  02
00576:  BZ    05A0
00578:  BRA    05AA
....................    {
....................       case '\a'   :  lcd_gotoxy(1,1);     break;
0057A:  MOVLW  01
0057C:  MOVWF  x9D
0057E:  MOVWF  x9E
00580:  RCALL  0450
00582:  BRA    05B4
.................... 
....................       case '\f'   :  lcd_send_byte(0,1);
00584:  CLRF   xA1
00586:  MOVLW  01
00588:  MOVWF  xA2
0058A:  RCALL  040A
....................                      delay_ms(2);
0058C:  MOVLW  02
0058E:  MOVWF  x9D
00590:  RCALL  0540
....................                     #if defined(LCD_EXTENDED_NEWLINE)
....................                      g_LcdX = 0;
....................                      g_LcdY = 0;
....................                     #endif
....................                      break;
00592:  BRA    05B4
.................... 
....................      #if defined(LCD_EXTENDED_NEWLINE)
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break;
....................       case '\n'   :
....................          while (g_LcdX++ < LCD_LINE_LENGTH)
....................          {
....................             lcd_send_byte(1, ' ');
....................          }
....................          lcd_gotoxy(1, g_LcdY+2);
....................          break;
....................      #else
....................       case '\n'   : lcd_gotoxy(1,2);        break;
00594:  MOVLW  01
00596:  MOVWF  x9D
00598:  MOVLW  02
0059A:  MOVWF  x9E
0059C:  RCALL  0450
0059E:  BRA    05B4
....................      #endif
....................      
....................       case '\b'   : lcd_send_byte(0,0x10);  break;
005A0:  CLRF   xA1
005A2:  MOVLW  10
005A4:  MOVWF  xA2
005A6:  RCALL  040A
005A8:  BRA    05B4
....................      
....................      #if defined(LCD_EXTENDED_NEWLINE)
....................       default     : 
....................          if (g_LcdX < LCD_LINE_LENGTH)
....................          {
....................             lcd_send_byte(1, c);
....................             g_LcdX++;
....................          }
....................          break;
....................      #else
....................       default     : lcd_send_byte(1,c);     break;
005AA:  MOVLW  01
005AC:  MOVWF  xA1
005AE:  MOVFF  9C,A2
005B2:  RCALL  040A
....................      #endif
....................    }
005B4:  RETURN 0
.................... }
....................  
.................... char lcd_getc(unsigned int8 x, unsigned int8 y)
.................... {
....................    char value;
.................... 
....................    lcd_gotoxy(x,y);
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low
....................    lcd_output_rs(1);
....................    value = lcd_read_byte();
....................    lcd_output_rs(0);
....................    
....................    return(value);
.................... }
.................... 
.................... // write a custom character to the ram
.................... // which is 0-7 and specifies which character array we are modifying.
.................... // ptr points to an array of 8 bytes, where each byte is the next row of
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and
.................... //    usually you will want to leave this byte 0x00.
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr)
.................... {
....................    unsigned int i;
.................... 
....................    which <<= 3;
....................    which &= 0x38;
.................... 
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address
.................... 
....................    for(i=0; i<8; i++)
....................    {
....................       lcd_send_byte(1, *ptr++);
....................    }
....................   
....................    #if defined(LCD_EXTENDED_NEWLINE)
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address
....................    #endif
.................... }
.................... 
.................... void lcd_cursor_on(int1 on)
.................... {
....................    if (on)
....................    {
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON
....................    }
....................    else
....................    {
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF
....................    }
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... char mystring[20]="    ";
.................... char fim_mystring[15]="    ";
.................... int16 angulo_inteiro;
.................... 
.................... float valor;
.................... float tensao=5.35;
....................   
.................... int16 servo1_cmd;
.................... int16 servo2_cmd;  
....................    
.................... #define max 4
.................... 
.................... #INT_TIMER1
.................... void  TIMER1_isr(void) 
.................... {
.................... valor= read_adc();     
*
00A10:  BSF    FC2.1
00A12:  BTFSC  FC2.1
00A14:  BRA    0A12
00A16:  MOVFF  FC4,02
00A1A:  MOVFF  FC3,01
00A1E:  MOVFF  FC4,03
00A22:  MOVFF  FC3,8F
00A26:  MOVFF  FC4,90
00A2A:  CALL   00AE
00A2E:  MOVFF  03,48
00A32:  MOVFF  02,47
00A36:  MOVFF  01,46
00A3A:  MOVFF  00,45
.................... delay_us(100); 
00A3E:  MOVLW  42
00A40:  MOVWF  00
00A42:  DECFSZ 00,F
00A44:  BRA    0A42
00A46:  NOP   
.................... tensao= (valor*5) /1024;
00A48:  MOVFF  48,9F
00A4C:  MOVFF  47,9E
00A50:  MOVFF  46,9D
00A54:  MOVFF  45,9C
00A58:  CLRF   xA3
00A5A:  CLRF   xA2
00A5C:  MOVLW  20
00A5E:  MOVWF  xA1
00A60:  MOVLW  81
00A62:  MOVWF  xA0
00A64:  CALL   00E4
00A68:  MOVFF  03,92
00A6C:  MOVFF  02,91
00A70:  MOVFF  01,90
00A74:  MOVFF  00,8F
00A78:  MOVFF  03,96
00A7C:  MOVFF  02,95
00A80:  MOVFF  01,94
00A84:  MOVFF  00,93
00A88:  CLRF   x9A
00A8A:  CLRF   x99
00A8C:  CLRF   x98
00A8E:  MOVLW  89
00A90:  MOVWF  x97
00A92:  CALL   01D6
00A96:  MOVFF  03,4C
00A9A:  MOVFF  02,4B
00A9E:  MOVFF  01,4A
00AA2:  MOVFF  00,49
.................... lcd_gotoxy(1,2); //Posicina o LCD na segunda linha e primeiro caracter
00AA6:  MOVLW  01
00AA8:  MOVWF  x9D
00AAA:  MOVLW  02
00AAC:  MOVWF  x9E
00AAE:  RCALL  0450
.................... printf(LCD_PUTC,"%2.2f volts     ",tensao);
00AB0:  MOVLW  89
00AB2:  MOVWF  FE9
00AB4:  MOVFF  4C,92
00AB8:  MOVFF  4B,91
00ABC:  MOVFF  4A,90
00AC0:  MOVFF  49,8F
00AC4:  MOVLW  02
00AC6:  MOVWF  x93
00AC8:  BRA    05B6
00ACA:  MOVLW  81
00ACC:  MOVWF  FF6
00ACE:  MOVLW  0B
00AD0:  MOVWF  FF7
00AD2:  MOVLW  0B
00AD4:  MOVWF  x8F
00AD6:  BRA    0730
.................... 
.................... servo2_cmd= 1000 + valor/1.024;
00AD8:  MOVFF  48,96
00ADC:  MOVFF  47,95
00AE0:  MOVFF  46,94
00AE4:  MOVFF  45,93
00AE8:  MOVLW  6F
00AEA:  MOVWF  x9A
00AEC:  MOVLW  12
00AEE:  MOVWF  x99
00AF0:  MOVLW  03
00AF2:  MOVWF  x98
00AF4:  MOVLW  7F
00AF6:  MOVWF  x97
00AF8:  CALL   01D6
00AFC:  BCF    FD8.1
00AFE:  CLRF   x92
00B00:  CLRF   x91
00B02:  MOVLW  7A
00B04:  MOVWF  x90
00B06:  MOVLW  88
00B08:  MOVWF  x8F
00B0A:  MOVFF  03,96
00B0E:  MOVFF  02,95
00B12:  MOVFF  01,94
00B16:  MOVFF  00,93
00B1A:  RCALL  0750
00B1C:  MOVFF  03,92
00B20:  MOVFF  02,91
00B24:  MOVFF  01,90
00B28:  MOVFF  00,8F
00B2C:  RCALL  09BA
00B2E:  MOVFF  02,50
00B32:  MOVFF  01,4F
.................... 
.................... output_high(PIN_C5);
00B36:  BCF    F94.5
00B38:  BSF    F8B.5
.................... delay_us(servo2_cmd);// comando dos SERVO 2
00B3A:  MOVFF  50,8F
00B3E:  INCF   x8F,F
00B40:  DECF   x8F,F
00B42:  BTFSC  FD8.2
00B44:  BRA    0B4C
00B46:  SETF   x90
00B48:  RCALL  09F2
00B4A:  BRA    0B40
00B4C:  MOVFF  4F,90
00B50:  RCALL  09F2
.................... output_low(PIN_C5);
00B52:  BCF    F94.5
00B54:  BCF    F8B.5
.................... 
.................... output_high(PIN_C4);
00B56:  BCF    F94.4
00B58:  BSF    F8B.4
.................... delay_us(servo1_cmd); // comando dos SERVO 1
00B5A:  MOVFF  4E,8F
00B5E:  INCF   x8F,F
00B60:  DECF   x8F,F
00B62:  BTFSC  FD8.2
00B64:  BRA    0B6C
00B66:  SETF   x90
00B68:  RCALL  09F2
00B6A:  BRA    0B60
00B6C:  MOVFF  4D,90
00B70:  RCALL  09F2
.................... output_low(PIN_C4);
00B72:  BCF    F94.4
00B74:  BCF    F8B.4
00B76:  BCF    F9E.0
00B78:  GOTO   0060
.................... }
.................... 
.................... void main()
*
01268:  CLRF   FF8
0126A:  BCF    FD0.7
0126C:  BSF    07.7
0126E:  MOVLW  60
01270:  MOVWF  FD3
01272:  BCF    F9B.6
01274:  BCF    F9B.7
01276:  BCF    FB8.3
01278:  MOVLW  0C
0127A:  MOVWF  FAF
0127C:  MOVLW  A2
0127E:  MOVWF  FAC
01280:  MOVLW  90
01282:  MOVWF  FAB
01284:  MOVLW  33
01286:  MOVWF  4C
01288:  MOVWF  4B
0128A:  MOVLW  2B
0128C:  MOVWF  4A
0128E:  MOVLW  81
01290:  MOVWF  49
01292:  CLRF   52
01294:  CLRF   51
01296:  MOVLB  F
01298:  CLRF   x38
0129A:  CLRF   x39
0129C:  CLRF   x3A
0129E:  CLRF   x3B
012A0:  CLRF   x3C
012A2:  CLRF   F77
012A4:  CLRF   F78
012A6:  CLRF   F79
012A8:  CLRF   1A
012AA:  CLRF   1B
012AC:  MOVLW  20
012AE:  MOVWF  20
012B0:  MOVWF  21
012B2:  MOVWF  22
012B4:  MOVWF  23
012B6:  CLRF   24
012B8:  MOVWF  34
012BA:  MOVWF  35
012BC:  MOVWF  36
012BE:  MOVWF  37
012C0:  CLRF   38
.................... {
.................... setup_adc(ADC_CLOCK_INTERNAL);
012C2:  MOVF   FC0,W
012C4:  ANDLW  C0
012C6:  IORLW  07
012C8:  MOVWF  FC0
012CA:  BSF    FC0.7
012CC:  BSF    FC2.0
.................... setup_adc_ports(sAN0);
012CE:  MOVF   FC1,W
012D0:  ANDLW  F0
012D2:  MOVWF  FC1
012D4:  MOVLW  01
012D6:  MOVWF  x38
012D8:  MOVLW  00
012DA:  MOVWF  x3C
012DC:  MOVWF  x39
012DE:  MOVWF  x3A
012E0:  MOVWF  x3B
.................... setup_timer_1(T1_INTERNAL|T1_DIV_BY_1); // (1/2)MHz * 65636 = 32,7 ms overflow
012E2:  MOVLW  07
012E4:  MOVWF  FCD
012E6:  CLRF   FCC
.................... 
.................... set_adc_channel(0); 
012E8:  MOVLW  00
012EA:  MOVWF  01
012EC:  MOVF   FC2,W
012EE:  ANDLW  83
012F0:  IORWF  01,W
012F2:  MOVWF  FC2
.................... 
.................... lcd_init();
012F4:  MOVLB  0
012F6:  BRA    0BFE
.................... printf("Projeto  SERVO\n\r"); 
012F8:  MOVLW  8E
012FA:  MOVWF  FF6
012FC:  MOVLW  0B
012FE:  MOVWF  FF7
01300:  RCALL  0CC8
.................... LCD_putc("Projeto  SERVO\n\r");
01302:  MOVLW  A0
01304:  MOVWF  FF6
01306:  MOVLW  0B
01308:  MOVWF  FF7
0130A:  BRA    0CEA
.................... delay_ms(1000);
0130C:  MOVLW  04
0130E:  MOVWF  53
01310:  CLRF   19
01312:  BTFSC  FF2.7
01314:  BSF    19.7
01316:  BCF    FF2.7
01318:  MOVLW  FA
0131A:  MOVWF  x9D
0131C:  CALL   0540
01320:  BTFSC  19.7
01322:  BSF    FF2.7
01324:  DECFSZ 53,F
01326:  BRA    1310
.................... 
.................... enable_interrupts(INT_TIMER1);
01328:  BSF    F9D.0
.................... enable_interrupts(GLOBAL);
0132A:  MOVLW  C0
0132C:  IORWF  FF2,F
.................... 
....................    while(1){  
....................    
....................       printf("\n\rDigite o angulo do servo entre  0 e 180 graus:\r\n");  // hang till input unless TIMEOUT used
0132E:  MOVLW  B2
01330:  MOVWF  FF6
01332:  MOVLW  0B
01334:  MOVWF  FF7
01336:  RCALL  0CC8
....................       get_string(mystring, max);
01338:  CLRF   54
0133A:  MOVLW  20
0133C:  MOVWF  53
0133E:  MOVLW  04
01340:  MOVWF  55
01342:  BRA    0D28
....................       angulo_inteiro=strtol(mystring, fim_mystring,10);
01344:  CLRF   54
01346:  MOVLW  20
01348:  MOVWF  53
0134A:  CLRF   56
0134C:  MOVLW  34
0134E:  MOVWF  55
01350:  MOVLW  0A
01352:  MOVWF  57
01354:  BRA    0E34
01356:  MOVFF  02,44
0135A:  MOVFF  01,43
....................       printf("\n\rAngulo digitado=%LU\r\n",angulo_inteiro);           
0135E:  MOVLW  E6
01360:  MOVWF  FF6
01362:  MOVLW  0B
01364:  MOVWF  FF7
01366:  MOVLW  12
01368:  MOVWF  53
0136A:  BRA    1198
0136C:  MOVLW  10
0136E:  MOVWF  FE9
01370:  MOVFF  44,54
01374:  MOVFF  43,53
01378:  BRA    11BA
0137A:  MOVLW  0D
0137C:  BTFSS  F9E.4
0137E:  BRA    137C
01380:  MOVWF  FAD
01382:  MOVLW  0A
01384:  BTFSS  F9E.4
01386:  BRA    1384
01388:  MOVWF  FAD
0138A:  CLRF   19
0138C:  BTFSC  FF2.7
0138E:  BSF    19.7
01390:  BCF    FF2.7
....................       servo1_cmd= 1000 + angulo_inteiro*5.5555;
01392:  MOVFF  44,90
01396:  MOVFF  43,8F
0139A:  CALL   00AE
0139E:  BTFSC  19.7
013A0:  BSF    FF2.7
013A2:  CLRF   19
013A4:  BTFSC  FF2.7
013A6:  BSF    19.7
013A8:  BCF    FF2.7
013AA:  MOVFF  03,9F
013AE:  MOVFF  02,9E
013B2:  MOVFF  01,9D
013B6:  MOVFF  00,9C
013BA:  MOVLW  A8
013BC:  MOVWF  xA3
013BE:  MOVLW  C6
013C0:  MOVWF  xA2
013C2:  MOVLW  31
013C4:  MOVWF  xA1
013C6:  MOVLW  81
013C8:  MOVWF  xA0
013CA:  CALL   00E4
013CE:  BTFSC  19.7
013D0:  BSF    FF2.7
013D2:  BCF    FD8.1
013D4:  CLRF   19
013D6:  BTFSC  FF2.7
013D8:  BSF    19.7
013DA:  BCF    FF2.7
013DC:  CLRF   x92
013DE:  CLRF   x91
013E0:  MOVLW  7A
013E2:  MOVWF  x90
013E4:  MOVLW  88
013E6:  MOVWF  x8F
013E8:  MOVFF  03,96
013EC:  MOVFF  02,95
013F0:  MOVFF  01,94
013F4:  MOVFF  00,93
013F8:  CALL   0750
013FC:  BTFSC  19.7
013FE:  BSF    FF2.7
01400:  CLRF   19
01402:  BTFSC  FF2.7
01404:  BSF    19.7
01406:  BCF    FF2.7
01408:  MOVFF  03,92
0140C:  MOVFF  02,91
01410:  MOVFF  01,90
01414:  MOVFF  00,8F
01418:  CALL   09BA
0141C:  BTFSC  19.7
0141E:  BSF    FF2.7
01420:  MOVFF  02,4E
01424:  MOVFF  01,4D
01428:  BRA    132E
....................              
....................    } 
.................... 
.................... }
0142A:  SLEEP 

Configuration Fuses:
   Word  1: E800   INTRC_IO NOPLLEN PRIMARY_ON FCMEN IESO
   Word  2: 3C1E   PUT BROWNOUT BORV19 NOWDT WDT32768
   Word  3: BF00   CCP2C1 PBADEN CCP3B5 HFOFST TIMER3C0 CCP2D2 MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
