CCS PCH C Compiler, Version 5.099, 54900               21-ago-21 15:50

               Filename:   C:\Users\wvair\Google Drive\Especialização em Mecatrônica EAD IPETEC 2019\Robótica Industrial\Microcontroladores PIC\Exemplos\Servo_PIC18F46K22\servo.lst

               ROM used:   5252 bytes (8%)
                           Largest free fragment is 60280
               RAM used:   95 (2%) at main() level
                           181 (5%) worst case
               Stack used: 0 locations
               Stack size: 31

*
00000:  GOTO   123E
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  BTFSS  F9D.0
00056:  GOTO   0060
0005A:  BTFSC  F9E.0
0005C:  GOTO   0A16
00060:  MOVFF  0E,00
00064:  MOVFF  0F,01
00068:  MOVFF  10,02
0006C:  MOVFF  11,03
00070:  MOVFF  0C,FE9
00074:  MOVFF  07,FEA
00078:  BSF    07.7
0007A:  MOVFF  08,FE1
0007E:  MOVFF  09,FE2
00082:  MOVFF  0A,FD9
00086:  MOVFF  0B,FDA
0008A:  MOVFF  12,FF3
0008E:  MOVFF  13,FF4
00092:  MOVFF  14,FFA
00096:  MOVFF  15,FF5
0009A:  MOVFF  16,FF6
0009E:  MOVFF  17,FF7
000A2:  MOVF   04,W
000A4:  MOVFF  06,FE0
000A8:  MOVFF  05,FD8
000AC:  RETFIE 0
.................... #include <servo.h>
.................... #include <18F46K22.h>
.................... //////////// Standard Header file for the PIC18F46K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46K22
000AE:  MOVLW  8E
000B0:  MOVWF  00
000B2:  MOVFF  9C,01
000B6:  MOVFF  9B,02
000BA:  CLRF   03
000BC:  MOVF   01,F
000BE:  BNZ   00D2
000C0:  MOVFF  02,01
000C4:  CLRF   02
000C6:  MOVLW  08
000C8:  SUBWF  00,F
000CA:  MOVF   01,F
000CC:  BNZ   00D2
000CE:  CLRF   00
000D0:  BRA    00E2
000D2:  BCF    FD8.0
000D4:  BTFSC  01.7
000D6:  BRA    00E0
000D8:  RLCF   02,F
000DA:  RLCF   01,F
000DC:  DECF   00,F
000DE:  BRA    00D2
000E0:  BCF    01.7
000E2:  RETURN 0
000E4:  MOVF   xA8,W
000E6:  BTFSC  FD8.2
000E8:  BRA    01CC
000EA:  MOVWF  00
000EC:  MOVF   xAC,W
000EE:  BTFSC  FD8.2
000F0:  BRA    01CC
000F2:  ADDWF  00,F
000F4:  BNC   00FE
000F6:  MOVLW  81
000F8:  ADDWF  00,F
000FA:  BC    01CC
000FC:  BRA    0106
000FE:  MOVLW  7F
00100:  SUBWF  00,F
00102:  BNC   01CC
00104:  BZ    01CC
00106:  MOVFF  A9,B0
0010A:  MOVF   xAD,W
0010C:  XORWF  xB0,F
0010E:  BSF    xA9.7
00110:  BSF    xAD.7
00112:  MOVF   xAB,W
00114:  MULWF  xAF
00116:  MOVFF  FF4,B2
0011A:  MOVF   xAA,W
0011C:  MULWF  xAE
0011E:  MOVFF  FF4,03
00122:  MOVFF  FF3,B1
00126:  MULWF  xAF
00128:  MOVF   FF3,W
0012A:  ADDWF  xB2,F
0012C:  MOVF   FF4,W
0012E:  ADDWFC xB1,F
00130:  MOVLW  00
00132:  ADDWFC 03,F
00134:  MOVF   xAB,W
00136:  MULWF  xAE
00138:  MOVF   FF3,W
0013A:  ADDWF  xB2,F
0013C:  MOVF   FF4,W
0013E:  ADDWFC xB1,F
00140:  MOVLW  00
00142:  CLRF   02
00144:  ADDWFC 03,F
00146:  ADDWFC 02,F
00148:  MOVF   xA9,W
0014A:  MULWF  xAF
0014C:  MOVF   FF3,W
0014E:  ADDWF  xB1,F
00150:  MOVF   FF4,W
00152:  ADDWFC 03,F
00154:  MOVLW  00
00156:  ADDWFC 02,F
00158:  MOVF   xA9,W
0015A:  MULWF  xAE
0015C:  MOVF   FF3,W
0015E:  ADDWF  03,F
00160:  MOVF   FF4,W
00162:  ADDWFC 02,F
00164:  MOVLW  00
00166:  CLRF   01
00168:  ADDWFC 01,F
0016A:  MOVF   xAB,W
0016C:  MULWF  xAD
0016E:  MOVF   FF3,W
00170:  ADDWF  xB1,F
00172:  MOVF   FF4,W
00174:  ADDWFC 03,F
00176:  MOVLW  00
00178:  ADDWFC 02,F
0017A:  ADDWFC 01,F
0017C:  MOVF   xAA,W
0017E:  MULWF  xAD
00180:  MOVF   FF3,W
00182:  ADDWF  03,F
00184:  MOVF   FF4,W
00186:  ADDWFC 02,F
00188:  MOVLW  00
0018A:  ADDWFC 01,F
0018C:  MOVF   xA9,W
0018E:  MULWF  xAD
00190:  MOVF   FF3,W
00192:  ADDWF  02,F
00194:  MOVF   FF4,W
00196:  ADDWFC 01,F
00198:  INCF   00,F
0019A:  BTFSC  01.7
0019C:  BRA    01A8
0019E:  RLCF   xB1,F
001A0:  RLCF   03,F
001A2:  RLCF   02,F
001A4:  RLCF   01,F
001A6:  DECF   00,F
001A8:  MOVLW  00
001AA:  BTFSS  xB1.7
001AC:  BRA    01C2
001AE:  INCF   03,F
001B0:  ADDWFC 02,F
001B2:  ADDWFC 01,F
001B4:  MOVF   01,W
001B6:  BNZ   01C2
001B8:  MOVF   02,W
001BA:  BNZ   01C2
001BC:  MOVF   03,W
001BE:  BNZ   01C2
001C0:  INCF   00,F
001C2:  BTFSC  xB0.7
001C4:  BSF    01.7
001C6:  BTFSS  xB0.7
001C8:  BCF    01.7
001CA:  BRA    01D4
001CC:  CLRF   00
001CE:  CLRF   01
001D0:  CLRF   02
001D2:  CLRF   03
001D4:  RETURN 0
001D6:  MOVF   x9F,W
001D8:  BTFSC  FD8.2
001DA:  BRA    0326
001DC:  MOVWF  xAB
001DE:  MOVF   xA3,W
001E0:  BTFSC  FD8.2
001E2:  BRA    0326
001E4:  SUBWF  xAB,F
001E6:  BNC   01F2
001E8:  MOVLW  7F
001EA:  ADDWF  xAB,F
001EC:  BTFSC  FD8.0
001EE:  BRA    0326
001F0:  BRA    01FE
001F2:  MOVLW  81
001F4:  SUBWF  xAB,F
001F6:  BTFSS  FD8.0
001F8:  BRA    0326
001FA:  BTFSC  FD8.2
001FC:  BRA    0326
001FE:  MOVFF  AB,00
00202:  CLRF   01
00204:  CLRF   02
00206:  CLRF   03
00208:  CLRF   xAA
0020A:  MOVFF  A0,A9
0020E:  BSF    xA9.7
00210:  MOVFF  A1,A8
00214:  MOVFF  A2,A7
00218:  MOVLW  19
0021A:  MOVWF  xAB
0021C:  MOVF   xA6,W
0021E:  SUBWF  xA7,F
00220:  BC    023C
00222:  MOVLW  01
00224:  SUBWF  xA8,F
00226:  BC    023C
00228:  SUBWF  xA9,F
0022A:  BC    023C
0022C:  SUBWF  xAA,F
0022E:  BC    023C
00230:  INCF   xAA,F
00232:  INCF   xA9,F
00234:  INCF   xA8,F
00236:  MOVF   xA6,W
00238:  ADDWF  xA7,F
0023A:  BRA    028C
0023C:  MOVF   xA5,W
0023E:  SUBWF  xA8,F
00240:  BC    0266
00242:  MOVLW  01
00244:  SUBWF  xA9,F
00246:  BC    0266
00248:  SUBWF  xAA,F
0024A:  BC    0266
0024C:  INCF   xAA,F
0024E:  INCF   xA9,F
00250:  MOVF   xA5,W
00252:  ADDWF  xA8,F
00254:  MOVF   xA6,W
00256:  ADDWF  xA7,F
00258:  BNC   028C
0025A:  INCF   xA8,F
0025C:  BNZ   028C
0025E:  INCF   xA9,F
00260:  BNZ   028C
00262:  INCF   xAA,F
00264:  BRA    028C
00266:  MOVF   xA4,W
00268:  IORLW  80
0026A:  SUBWF  xA9,F
0026C:  BC    028A
0026E:  MOVLW  01
00270:  SUBWF  xAA,F
00272:  BC    028A
00274:  INCF   xAA,F
00276:  MOVF   xA4,W
00278:  IORLW  80
0027A:  ADDWF  xA9,F
0027C:  MOVF   xA5,W
0027E:  ADDWF  xA8,F
00280:  BNC   0254
00282:  INCF   xA9,F
00284:  BNZ   0254
00286:  INCF   xAA,F
00288:  BRA    0254
0028A:  BSF    03.0
0028C:  DECFSZ xAB,F
0028E:  BRA    0292
00290:  BRA    02A8
00292:  BCF    FD8.0
00294:  RLCF   xA7,F
00296:  RLCF   xA8,F
00298:  RLCF   xA9,F
0029A:  RLCF   xAA,F
0029C:  BCF    FD8.0
0029E:  RLCF   03,F
002A0:  RLCF   02,F
002A2:  RLCF   01,F
002A4:  RLCF   xAC,F
002A6:  BRA    021C
002A8:  BTFSS  xAC.0
002AA:  BRA    02B8
002AC:  BCF    FD8.0
002AE:  RRCF   01,F
002B0:  RRCF   02,F
002B2:  RRCF   03,F
002B4:  RRCF   xAC,F
002B6:  BRA    02BC
002B8:  DECF   00,F
002BA:  BZ    0326
002BC:  BTFSC  xAC.7
002BE:  BRA    02FC
002C0:  BCF    FD8.0
002C2:  RLCF   xA7,F
002C4:  RLCF   xA8,F
002C6:  RLCF   xA9,F
002C8:  RLCF   xAA,F
002CA:  MOVF   xA6,W
002CC:  SUBWF  xA7,F
002CE:  BC    02DE
002D0:  MOVLW  01
002D2:  SUBWF  xA8,F
002D4:  BC    02DE
002D6:  SUBWF  xA9,F
002D8:  BC    02DE
002DA:  SUBWF  xAA,F
002DC:  BNC   0312
002DE:  MOVF   xA5,W
002E0:  SUBWF  xA8,F
002E2:  BC    02EE
002E4:  MOVLW  01
002E6:  SUBWF  xA9,F
002E8:  BC    02EE
002EA:  SUBWF  xAA,F
002EC:  BNC   0312
002EE:  MOVF   xA4,W
002F0:  IORLW  80
002F2:  SUBWF  xA9,F
002F4:  BC    02FC
002F6:  MOVLW  01
002F8:  SUBWF  xAA,F
002FA:  BNC   0312
002FC:  INCF   03,F
002FE:  BNZ   0312
00300:  INCF   02,F
00302:  BNZ   0312
00304:  INCF   01,F
00306:  BNZ   0312
00308:  INCF   00,F
0030A:  BZ    0326
0030C:  RRCF   01,F
0030E:  RRCF   02,F
00310:  RRCF   03,F
00312:  MOVFF  A0,AB
00316:  MOVF   xA4,W
00318:  XORWF  xAB,F
0031A:  BTFSS  xAB.7
0031C:  BRA    0322
0031E:  BSF    01.7
00320:  BRA    032E
00322:  BCF    01.7
00324:  BRA    032E
00326:  CLRF   00
00328:  CLRF   01
0032A:  CLRF   02
0032C:  CLRF   03
0032E:  RETURN 0
*
00476:  MOVF   xA8,W
00478:  SUBLW  B6
0047A:  MOVWF  xA8
0047C:  CLRF   03
0047E:  MOVFF  A9,AC
00482:  BSF    xA9.7
00484:  BCF    FD8.0
00486:  RRCF   xA9,F
00488:  RRCF   xAA,F
0048A:  RRCF   xAB,F
0048C:  RRCF   03,F
0048E:  RRCF   02,F
00490:  RRCF   01,F
00492:  RRCF   00,F
00494:  DECFSZ xA8,F
00496:  BRA    0484
00498:  BTFSS  xAC.7
0049A:  BRA    04B2
0049C:  COMF   00,F
0049E:  COMF   01,F
004A0:  COMF   02,F
004A2:  COMF   03,F
004A4:  INCF   00,F
004A6:  BTFSC  FD8.2
004A8:  INCF   01,F
004AA:  BTFSC  FD8.2
004AC:  INCF   02,F
004AE:  BTFSC  FD8.2
004B0:  INCF   03,F
004B2:  RETURN 0
004B4:  BTFSC  FD8.1
004B6:  BRA    04BE
004B8:  CLRF   FEA
004BA:  MOVLW  B0
004BC:  MOVWF  FE9
004BE:  CLRF   00
004C0:  CLRF   01
004C2:  CLRF   02
004C4:  CLRF   03
004C6:  CLRF   xB0
004C8:  CLRF   xB1
004CA:  CLRF   xB2
004CC:  CLRF   xB3
004CE:  MOVF   xAF,W
004D0:  IORWF  xAE,W
004D2:  IORWF  xAD,W
004D4:  IORWF  xAC,W
004D6:  BZ    0530
004D8:  MOVLW  20
004DA:  MOVWF  xB4
004DC:  BCF    FD8.0
004DE:  RLCF   xA8,F
004E0:  RLCF   xA9,F
004E2:  RLCF   xAA,F
004E4:  RLCF   xAB,F
004E6:  RLCF   xB0,F
004E8:  RLCF   xB1,F
004EA:  RLCF   xB2,F
004EC:  RLCF   xB3,F
004EE:  MOVF   xAF,W
004F0:  SUBWF  xB3,W
004F2:  BNZ   0504
004F4:  MOVF   xAE,W
004F6:  SUBWF  xB2,W
004F8:  BNZ   0504
004FA:  MOVF   xAD,W
004FC:  SUBWF  xB1,W
004FE:  BNZ   0504
00500:  MOVF   xAC,W
00502:  SUBWF  xB0,W
00504:  BNC   0524
00506:  MOVF   xAC,W
00508:  SUBWF  xB0,F
0050A:  MOVF   xAD,W
0050C:  BTFSS  FD8.0
0050E:  INCFSZ xAD,W
00510:  SUBWF  xB1,F
00512:  MOVF   xAE,W
00514:  BTFSS  FD8.0
00516:  INCFSZ xAE,W
00518:  SUBWF  xB2,F
0051A:  MOVF   xAF,W
0051C:  BTFSS  FD8.0
0051E:  INCFSZ xAF,W
00520:  SUBWF  xB3,F
00522:  BSF    FD8.0
00524:  RLCF   00,F
00526:  RLCF   01,F
00528:  RLCF   02,F
0052A:  RLCF   03,F
0052C:  DECFSZ xB4,F
0052E:  BRA    04DC
00530:  MOVFF  B0,FEF
00534:  MOVFF  B1,FEC
00538:  MOVFF  B2,FEC
0053C:  MOVFF  B3,FEC
00540:  RETURN 0
*
005C0:  MOVF   FE9,W
005C2:  MOVWF  xA0
005C4:  MOVF   x9F,W
005C6:  MOVWF  xA2
005C8:  BZ    05FC
005CA:  MOVFF  9E,AB
005CE:  MOVFF  9D,AA
005D2:  MOVFF  9C,A9
005D6:  MOVFF  9B,A8
005DA:  CLRF   xAF
005DC:  CLRF   xAE
005DE:  MOVLW  20
005E0:  MOVWF  xAD
005E2:  MOVLW  82
005E4:  MOVWF  xAC
005E6:  RCALL  00E4
005E8:  MOVFF  03,9E
005EC:  MOVFF  02,9D
005F0:  MOVFF  01,9C
005F4:  MOVFF  00,9B
005F8:  DECFSZ xA2,F
005FA:  BRA    05CA
005FC:  MOVFF  9E,AB
00600:  MOVFF  9D,AA
00604:  MOVFF  9C,A9
00608:  MOVFF  9B,A8
0060C:  RCALL  0476
0060E:  MOVFF  03,9E
00612:  MOVFF  02,9D
00616:  MOVFF  01,9C
0061A:  MOVFF  00,9B
0061E:  BTFSS  x9E.7
00620:  BRA    063C
00622:  DECF   xA0,F
00624:  BSF    xA0.5
00626:  COMF   x9B,F
00628:  COMF   x9C,F
0062A:  COMF   x9D,F
0062C:  COMF   x9E,F
0062E:  INCF   x9B,F
00630:  BTFSC  FD8.2
00632:  INCF   x9C,F
00634:  BTFSC  FD8.2
00636:  INCF   x9D,F
00638:  BTFSC  FD8.2
0063A:  INCF   x9E,F
0063C:  MOVLW  3B
0063E:  MOVWF  xA7
00640:  MOVLW  9A
00642:  MOVWF  xA6
00644:  MOVLW  CA
00646:  MOVWF  xA5
00648:  CLRF   xA4
0064A:  MOVLW  0A
0064C:  MOVWF  xA2
0064E:  MOVF   x9F,W
00650:  BTFSC  FD8.2
00652:  INCF   xA0,F
00654:  BSF    FD8.1
00656:  CLRF   FEA
00658:  MOVLW  9B
0065A:  MOVWF  FE9
0065C:  MOVFF  9E,AB
00660:  MOVFF  9D,AA
00664:  MOVFF  9C,A9
00668:  MOVFF  9B,A8
0066C:  MOVFF  A7,AF
00670:  MOVFF  A6,AE
00674:  MOVFF  A5,AD
00678:  MOVFF  A4,AC
0067C:  RCALL  04B4
0067E:  MOVF   01,W
00680:  MOVF   00,F
00682:  BNZ   06A2
00684:  INCF   x9F,W
00686:  SUBWF  xA2,W
00688:  BZ    06A2
0068A:  MOVF   xA0,W
0068C:  BZ    06A6
0068E:  ANDLW  0F
00690:  SUBWF  xA2,W
00692:  BZ    0696
00694:  BC    0704
00696:  BTFSC  xA0.7
00698:  BRA    0704
0069A:  BTFSC  xA0.6
0069C:  BRA    06A6
0069E:  MOVLW  20
006A0:  BRA    06FC
006A2:  MOVLW  20
006A4:  ANDWF  xA0,F
006A6:  BTFSS  xA0.5
006A8:  BRA    06C2
006AA:  BCF    xA0.5
006AC:  MOVF   x9F,W
006AE:  BTFSS  FD8.2
006B0:  DECF   xA0,F
006B2:  MOVF   00,W
006B4:  MOVWF  xA0
006B6:  MOVLW  2D
006B8:  MOVWF  xA8
006BA:  RCALL  0570
006BC:  MOVF   xA0,W
006BE:  MOVWF  00
006C0:  CLRF   xA0
006C2:  MOVF   x9F,W
006C4:  SUBWF  xA2,W
006C6:  BNZ   06DC
006C8:  MOVF   00,W
006CA:  MOVWF  xA0
006CC:  MOVLW  2E
006CE:  MOVWF  xA8
006D0:  RCALL  0570
006D2:  MOVF   xA0,W
006D4:  MOVWF  00
006D6:  MOVLW  20
006D8:  ANDWF  xA0,F
006DA:  MOVLW  00
006DC:  MOVLW  30
006DE:  BTFSS  xA0.5
006E0:  BRA    06FC
006E2:  BCF    xA0.5
006E4:  MOVF   x9F,W
006E6:  BTFSS  FD8.2
006E8:  DECF   xA0,F
006EA:  MOVF   00,W
006EC:  MOVWF  xA0
006EE:  MOVLW  2D
006F0:  MOVWF  xA8
006F2:  RCALL  0570
006F4:  MOVF   xA0,W
006F6:  MOVWF  00
006F8:  CLRF   xA0
006FA:  MOVLW  30
006FC:  ADDWF  00,F
006FE:  MOVFF  00,A8
00702:  RCALL  0570
00704:  BCF    FD8.1
00706:  MOVFF  A7,AB
0070A:  MOVFF  A6,AA
0070E:  MOVFF  A5,A9
00712:  MOVFF  A4,A8
00716:  CLRF   xAF
00718:  CLRF   xAE
0071A:  CLRF   xAD
0071C:  MOVLW  0A
0071E:  MOVWF  xAC
00720:  RCALL  04B4
00722:  MOVFF  03,A7
00726:  MOVFF  02,A6
0072A:  MOVFF  01,A5
0072E:  MOVFF  00,A4
00732:  DECFSZ xA2,F
00734:  BRA    0654
00736:  RETURN 0
00738:  TBLRD*+
0073A:  MOVFF  FF6,9C
0073E:  MOVFF  FF7,9D
00742:  MOVFF  FF5,A8
00746:  RCALL  0570
00748:  MOVFF  9C,FF6
0074C:  MOVFF  9D,FF7
00750:  DECFSZ x9B,F
00752:  BRA    0738
00754:  RETURN 0
00756:  MOVLW  80
00758:  BTFSC  FD8.1
0075A:  XORWF  xA0,F
0075C:  CLRF   xA5
0075E:  CLRF   xA6
00760:  MOVFF  9C,A4
00764:  MOVF   xA0,W
00766:  XORWF  xA4,F
00768:  MOVF   x9B,W
0076A:  BTFSC  FD8.2
0076C:  BRA    0926
0076E:  MOVWF  xA3
00770:  MOVWF  00
00772:  MOVF   x9F,W
00774:  BTFSC  FD8.2
00776:  BRA    0938
00778:  SUBWF  xA3,F
0077A:  BTFSC  FD8.2
0077C:  BRA    0880
0077E:  BNC   07FA
00780:  MOVFF  A0,A9
00784:  BSF    xA9.7
00786:  MOVFF  A1,A8
0078A:  MOVFF  A2,A7
0078E:  CLRF   xA6
00790:  BCF    FD8.0
00792:  RRCF   xA9,F
00794:  RRCF   xA8,F
00796:  RRCF   xA7,F
00798:  RRCF   xA6,F
0079A:  DECFSZ xA3,F
0079C:  BRA    078E
0079E:  BTFSS  xA4.7
007A0:  BRA    07A8
007A2:  BSF    xA5.0
007A4:  BRA    0960
007A6:  BCF    xA5.0
007A8:  BCF    xA3.0
007AA:  BSF    xA5.4
007AC:  CLRF   FEA
007AE:  MOVLW  9E
007B0:  MOVWF  FE9
007B2:  BRA    0986
007B4:  BCF    xA5.4
007B6:  BTFSC  xA4.7
007B8:  BRA    07CE
007BA:  BTFSS  xA3.0
007BC:  BRA    07E4
007BE:  RRCF   xA9,F
007C0:  RRCF   xA8,F
007C2:  RRCF   xA7,F
007C4:  RRCF   xA6,F
007C6:  INCF   00,F
007C8:  BTFSC  FD8.2
007CA:  BRA    0956
007CC:  BRA    07E4
007CE:  BTFSC  xA9.7
007D0:  BRA    07EA
007D2:  BCF    FD8.0
007D4:  RLCF   xA6,F
007D6:  RLCF   xA7,F
007D8:  RLCF   xA8,F
007DA:  RLCF   xA9,F
007DC:  DECF   00,F
007DE:  BTFSC  FD8.2
007E0:  BRA    0956
007E2:  BRA    07CE
007E4:  BSF    xA5.6
007E6:  BRA    08BE
007E8:  BCF    xA5.6
007EA:  MOVFF  9C,A4
007EE:  BTFSS  x9C.7
007F0:  BRA    07F6
007F2:  BSF    xA9.7
007F4:  BRA    0948
007F6:  BCF    xA9.7
007F8:  BRA    0948
007FA:  MOVFF  9F,A3
007FE:  MOVFF  9F,00
00802:  MOVF   x9B,W
00804:  SUBWF  xA3,F
00806:  MOVFF  9C,A9
0080A:  BSF    xA9.7
0080C:  MOVFF  9D,A8
00810:  MOVFF  9E,A7
00814:  CLRF   xA6
00816:  BCF    FD8.0
00818:  RRCF   xA9,F
0081A:  RRCF   xA8,F
0081C:  RRCF   xA7,F
0081E:  RRCF   xA6,F
00820:  DECFSZ xA3,F
00822:  BRA    0814
00824:  BTFSS  xA4.7
00826:  BRA    082E
00828:  BSF    xA5.1
0082A:  BRA    0960
0082C:  BCF    xA5.1
0082E:  BCF    xA3.0
00830:  BSF    xA5.5
00832:  CLRF   FEA
00834:  MOVLW  A2
00836:  MOVWF  FE9
00838:  BRA    0986
0083A:  BCF    xA5.5
0083C:  BTFSC  xA4.7
0083E:  BRA    0854
00840:  BTFSS  xA3.0
00842:  BRA    086A
00844:  RRCF   xA9,F
00846:  RRCF   xA8,F
00848:  RRCF   xA7,F
0084A:  RRCF   xA6,F
0084C:  INCF   00,F
0084E:  BTFSC  FD8.2
00850:  BRA    0956
00852:  BRA    086A
00854:  BTFSC  xA9.7
00856:  BRA    0870
00858:  BCF    FD8.0
0085A:  RLCF   xA6,F
0085C:  RLCF   xA7,F
0085E:  RLCF   xA8,F
00860:  RLCF   xA9,F
00862:  DECF   00,F
00864:  BTFSC  FD8.2
00866:  BRA    0956
00868:  BRA    0854
0086A:  BSF    xA5.7
0086C:  BRA    08BE
0086E:  BCF    xA5.7
00870:  MOVFF  A0,A4
00874:  BTFSS  xA0.7
00876:  BRA    087C
00878:  BSF    xA9.7
0087A:  BRA    0948
0087C:  BCF    xA9.7
0087E:  BRA    0948
00880:  MOVFF  A0,A9
00884:  BSF    xA9.7
00886:  MOVFF  A1,A8
0088A:  MOVFF  A2,A7
0088E:  BTFSS  xA4.7
00890:  BRA    089A
00892:  BCF    xA9.7
00894:  BSF    xA5.2
00896:  BRA    0960
00898:  BCF    xA5.2
0089A:  CLRF   xA6
0089C:  BCF    xA3.0
0089E:  CLRF   FEA
008A0:  MOVLW  9E
008A2:  MOVWF  FE9
008A4:  BRA    0986
008A6:  BTFSC  xA4.7
008A8:  BRA    08E2
008AA:  MOVFF  9C,A4
008AE:  BTFSS  xA3.0
008B0:  BRA    08BE
008B2:  RRCF   xA9,F
008B4:  RRCF   xA8,F
008B6:  RRCF   xA7,F
008B8:  RRCF   xA6,F
008BA:  INCF   00,F
008BC:  BZ    0956
008BE:  BTFSS  xA6.7
008C0:  BRA    08D8
008C2:  INCF   xA7,F
008C4:  BNZ   08D8
008C6:  INCF   xA8,F
008C8:  BNZ   08D8
008CA:  INCF   xA9,F
008CC:  BNZ   08D8
008CE:  RRCF   xA9,F
008D0:  RRCF   xA8,F
008D2:  RRCF   xA7,F
008D4:  INCF   00,F
008D6:  BZ    0956
008D8:  BTFSC  xA5.6
008DA:  BRA    07E8
008DC:  BTFSC  xA5.7
008DE:  BRA    086E
008E0:  BRA    091A
008E2:  MOVLW  80
008E4:  XORWF  xA9,F
008E6:  BTFSS  xA9.7
008E8:  BRA    08F2
008EA:  BRA    0960
008EC:  MOVFF  A0,A4
008F0:  BRA    0906
008F2:  MOVFF  9C,A4
008F6:  MOVF   xA9,F
008F8:  BNZ   0906
008FA:  MOVF   xA8,F
008FC:  BNZ   0906
008FE:  MOVF   xA7,F
00900:  BNZ   0906
00902:  CLRF   00
00904:  BRA    0948
00906:  BTFSC  xA9.7
00908:  BRA    091A
0090A:  BCF    FD8.0
0090C:  RLCF   xA6,F
0090E:  RLCF   xA7,F
00910:  RLCF   xA8,F
00912:  RLCF   xA9,F
00914:  DECFSZ 00,F
00916:  BRA    0906
00918:  BRA    0956
0091A:  BTFSS  xA4.7
0091C:  BRA    0922
0091E:  BSF    xA9.7
00920:  BRA    0948
00922:  BCF    xA9.7
00924:  BRA    0948
00926:  MOVFF  9F,00
0092A:  MOVFF  A0,A9
0092E:  MOVFF  A1,A8
00932:  MOVFF  A2,A7
00936:  BRA    0948
00938:  MOVFF  9B,00
0093C:  MOVFF  9C,A9
00940:  MOVFF  9D,A8
00944:  MOVFF  9E,A7
00948:  MOVFF  A9,01
0094C:  MOVFF  A8,02
00950:  MOVFF  A7,03
00954:  BRA    09BE
00956:  CLRF   00
00958:  CLRF   01
0095A:  CLRF   02
0095C:  CLRF   03
0095E:  BRA    09BE
00960:  CLRF   xA6
00962:  COMF   xA7,F
00964:  COMF   xA8,F
00966:  COMF   xA9,F
00968:  COMF   xA6,F
0096A:  INCF   xA6,F
0096C:  BNZ   0978
0096E:  INCF   xA7,F
00970:  BNZ   0978
00972:  INCF   xA8,F
00974:  BNZ   0978
00976:  INCF   xA9,F
00978:  BTFSC  xA5.0
0097A:  BRA    07A6
0097C:  BTFSC  xA5.1
0097E:  BRA    082C
00980:  BTFSC  xA5.2
00982:  BRA    0898
00984:  BRA    08EC
00986:  MOVF   FEF,W
00988:  ADDWF  xA7,F
0098A:  BNC   0996
0098C:  INCF   xA8,F
0098E:  BNZ   0996
00990:  INCF   xA9,F
00992:  BTFSC  FD8.2
00994:  BSF    xA3.0
00996:  MOVF   FED,F
00998:  MOVF   FEF,W
0099A:  ADDWF  xA8,F
0099C:  BNC   09A4
0099E:  INCF   xA9,F
009A0:  BTFSC  FD8.2
009A2:  BSF    xA3.0
009A4:  MOVF   FED,F
009A6:  MOVF   FEF,W
009A8:  BTFSC  FEF.7
009AA:  BRA    09AE
009AC:  XORLW  80
009AE:  ADDWF  xA9,F
009B0:  BTFSC  FD8.0
009B2:  BSF    xA3.0
009B4:  BTFSC  xA5.4
009B6:  BRA    07B4
009B8:  BTFSC  xA5.5
009BA:  BRA    083A
009BC:  BRA    08A6
009BE:  RETURN 0
009C0:  MOVLW  8E
009C2:  MOVWF  00
009C4:  MOVF   x9B,W
009C6:  SUBWF  00,F
009C8:  MOVFF  9C,02
009CC:  MOVFF  9D,01
009D0:  BSF    02.7
009D2:  MOVF   00,F
009D4:  BZ    09E8
009D6:  BCF    FD8.0
009D8:  MOVF   02,F
009DA:  BNZ   09E0
009DC:  MOVF   01,F
009DE:  BZ    09E8
009E0:  RRCF   02,F
009E2:  RRCF   01,F
009E4:  DECFSZ 00,F
009E6:  BRA    09D6
009E8:  BTFSS  x9C.7
009EA:  BRA    09F6
009EC:  COMF   01,F
009EE:  COMF   02,F
009F0:  INCF   01,F
009F2:  BTFSC  FD8.2
009F4:  INCF   02,F
009F6:  RETURN 0
*
00B82:  DATA 25,32
00B84:  DATA 2E,32
00B86:  DATA 66,20
00B88:  DATA 76,6F
00B8A:  DATA 6C,74
00B8C:  DATA 73,20
00B8E:  DATA 20,20
00B90:  DATA 20,20
00B92:  DATA 00,00
00B94:  DATA 50,72
00B96:  DATA 6F,6A
00B98:  DATA 65,74
00B9A:  DATA 6F,20
00B9C:  DATA 20,53
00B9E:  DATA 45,52
00BA0:  DATA 56,4F
00BA2:  DATA 0A,0D
00BA4:  DATA 00,00
00BA6:  DATA 25,32
00BA8:  DATA 2E,32
00BAA:  DATA 66,20
00BAC:  DATA 76,6F
00BAE:  DATA 6C,74
00BB0:  DATA 73,20
00BB2:  DATA 20,20
00BB4:  DATA 20,20
00BB6:  DATA 00,00
00BB8:  DATA 0A,0D
00BBA:  DATA 44,69
00BBC:  DATA 67,69
00BBE:  DATA 74,65
00BC0:  DATA 20,6F
00BC2:  DATA 20,61
00BC4:  DATA 6E,67
00BC6:  DATA 75,6C
00BC8:  DATA 6F,20
00BCA:  DATA 64,6F
00BCC:  DATA 20,73
00BCE:  DATA 65,72
00BD0:  DATA 76,6F
00BD2:  DATA 20,65
00BD4:  DATA 6E,74
00BD6:  DATA 72,65
00BD8:  DATA 20,20
00BDA:  DATA 30,20
00BDC:  DATA 65,20
00BDE:  DATA 31,38
00BE0:  DATA 30,20
00BE2:  DATA 67,72
00BE4:  DATA 61,75
00BE6:  DATA 73,3A
00BE8:  DATA 0D,0A
00BEA:  DATA 00,00
00BEC:  DATA 0A,0D
00BEE:  DATA 41,6E
00BF0:  DATA 67,75
00BF2:  DATA 6C,6F
00BF4:  DATA 20,64
00BF6:  DATA 69,67
00BF8:  DATA 69,74
00BFA:  DATA 61,64
00BFC:  DATA 6F,3D
00BFE:  DATA 25,4C
00C00:  DATA 55,0D
00C02:  DATA 0A,00
*
00CCE:  TBLRD*+
00CD0:  MOVF   FF5,F
00CD2:  BZ    0CEE
00CD4:  MOVFF  FF6,5F
00CD8:  MOVFF  FF7,60
00CDC:  MOVF   FF5,W
00CDE:  BTFSS  F9E.4
00CE0:  BRA    0CDE
00CE2:  MOVWF  FAD
00CE4:  MOVFF  5F,FF6
00CE8:  MOVFF  60,FF7
00CEC:  BRA    0CCE
00CEE:  RETURN 0
*
00DBA:  MOVF   x94,W
00DBC:  XORWF  x96,W
00DBE:  ANDLW  80
00DC0:  MOVWF  x98
00DC2:  BTFSS  x94.7
00DC4:  BRA    0DD0
00DC6:  COMF   x93,F
00DC8:  COMF   x94,F
00DCA:  INCF   x93,F
00DCC:  BTFSC  FD8.2
00DCE:  INCF   x94,F
00DD0:  BTFSS  x96.7
00DD2:  BRA    0DDE
00DD4:  COMF   x95,F
00DD6:  COMF   x96,F
00DD8:  INCF   x95,F
00DDA:  BTFSC  FD8.2
00DDC:  INCF   x96,F
00DDE:  MOVF   x93,W
00DE0:  MULWF  x95
00DE2:  MOVFF  FF3,01
00DE6:  MOVFF  FF4,00
00DEA:  MULWF  x96
00DEC:  MOVF   FF3,W
00DEE:  ADDWF  00,F
00DF0:  MOVF   x94,W
00DF2:  MULWF  x95
00DF4:  MOVF   FF3,W
00DF6:  ADDWFC 00,W
00DF8:  MOVWF  02
00DFA:  BTFSS  x98.7
00DFC:  BRA    0E08
00DFE:  COMF   01,F
00E00:  COMF   02,F
00E02:  INCF   01,F
00E04:  BTFSC  FD8.2
00E06:  INCF   02,F
00E08:  GOTO   10A8 (RETURN)
*
0116E:  TBLRD*+
01170:  MOVFF  FF6,60
01174:  MOVFF  FF7,61
01178:  MOVF   FF5,W
0117A:  BTFSS  F9E.4
0117C:  BRA    117A
0117E:  MOVWF  FAD
01180:  MOVFF  60,FF6
01184:  MOVFF  61,FF7
01188:  DECFSZ 5F,F
0118A:  BRA    116E
0118C:  GOTO   13C8 (RETURN)
01190:  MOVFF  FEA,67
01194:  MOVFF  FE9,66
01198:  SWAPF  x60,W
0119A:  IORLW  F0
0119C:  MOVWF  x62
0119E:  ADDWF  x62,F
011A0:  ADDLW  E2
011A2:  MOVWF  x63
011A4:  ADDLW  32
011A6:  MOVWF  x65
011A8:  MOVF   x60,W
011AA:  ANDLW  0F
011AC:  ADDWF  x63,F
011AE:  ADDWF  x63,F
011B0:  ADDWF  x65,F
011B2:  ADDLW  E9
011B4:  MOVWF  x64
011B6:  ADDWF  x64,F
011B8:  ADDWF  x64,F
011BA:  SWAPF  5F,W
011BC:  ANDLW  0F
011BE:  ADDWF  x64,F
011C0:  ADDWF  x65,F
011C2:  RLCF   x64,F
011C4:  RLCF   x65,F
011C6:  COMF   x65,F
011C8:  RLCF   x65,F
011CA:  MOVF   5F,W
011CC:  ANDLW  0F
011CE:  ADDWF  x65,F
011D0:  RLCF   x62,F
011D2:  MOVLW  07
011D4:  MOVWF  x61
011D6:  MOVLW  0A
011D8:  DECF   x64,F
011DA:  ADDWF  x65,F
011DC:  BNC   11D8
011DE:  DECF   x63,F
011E0:  ADDWF  x64,F
011E2:  BNC   11DE
011E4:  DECF   x62,F
011E6:  ADDWF  x63,F
011E8:  BNC   11E4
011EA:  DECF   x61,F
011EC:  ADDWF  x62,F
011EE:  BNC   11EA
011F0:  CLRF   FEA
011F2:  MOVLW  61
011F4:  MOVWF  FE9
011F6:  MOVLW  07
011F8:  ANDWF  x66,W
011FA:  BCF    x66.6
011FC:  ADDWF  FE9,F
011FE:  MOVLW  00
01200:  ADDWFC FEA,F
01202:  MOVF   FE9,W
01204:  SUBLW  65
01206:  BNZ   120E
01208:  MOVF   FEA,F
0120A:  BNZ   120E
0120C:  BSF    x66.6
0120E:  MOVF   FEF,W
01210:  MOVWF  00
01212:  BNZ   1224
01214:  BTFSC  x66.6
01216:  BRA    1224
01218:  BTFSC  x66.4
0121A:  BRA    1234
0121C:  BTFSC  x66.3
0121E:  BRA    1224
01220:  MOVLW  20
01222:  BRA    122A
01224:  BSF    x66.3
01226:  BCF    x66.4
01228:  MOVLW  30
0122A:  ADDWF  00,F
0122C:  MOVF   00,W
0122E:  BTFSS  F9E.4
01230:  BRA    122E
01232:  MOVWF  FAD
01234:  MOVF   FEE,W
01236:  BTFSS  x66.6
01238:  BRA    1202
0123A:  GOTO   13D6 (RETURN)
.................... 
.................... #list
.................... 
.................... #device ADC=10
.................... 
.................... #FUSES NOWDT                    //No Watch Dog Timer
.................... #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale
.................... #FUSES NOBROWNOUT               //No brownout reset
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O
.................... #FUSES NOXINST                  //Extended set extension and Indexed Addressing mode disabled (Legacy mode)
.................... 
.................... #use delay(internal=8MHz,restart_wdt)
*
00542:  CLRF   FEA
00544:  MOVLW  A9
00546:  MOVWF  FE9
00548:  MOVF   FEF,W
0054A:  BZ    056E
0054C:  MOVLW  02
0054E:  MOVWF  01
00550:  MOVLW  BF
00552:  MOVWF  00
00554:  CLRWDT
00556:  DECFSZ 00,F
00558:  BRA    0554
0055A:  DECFSZ 01,F
0055C:  BRA    0550
0055E:  MOVLW  96
00560:  MOVWF  00
00562:  DECFSZ 00,F
00564:  BRA    0562
00566:  BRA    0568
00568:  CLRWDT
0056A:  DECFSZ FEF,F
0056C:  BRA    054C
0056E:  RETURN 0
*
009F8:  MOVLW  09
009FA:  SUBWF  x9C,F
009FC:  BNC   0A14
009FE:  CLRF   FEA
00A00:  MOVLW  9C
00A02:  MOVWF  FE9
00A04:  BCF    FD8.0
00A06:  RRCF   FEF,F
00A08:  MOVF   FEF,W
00A0A:  BZ    0A14
00A0C:  BRA    0A10
00A0E:  CLRWDT
00A10:  DECFSZ FEF,F
00A12:  BRA    0A0E
00A14:  RETURN 0
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=PORT1)
*
00CF0:  BTFSS  F9E.4
00CF2:  BRA    0CF0
00CF4:  MOVWF  FAD
00CF6:  GOTO   0CFE (RETURN)
.................... 
.................... 
.................... // acesso aos pinos:
.................... #define LCD_ENABLE_PIN  PIN_E1
.................... #define LCD_RS_PIN      PIN_E0
.................... #define LCD_RW_PIN      PIN_E2
.................... #define LCD_DATA4       PIN_D4
.................... #define LCD_DATA5       PIN_D5
.................... #define LCD_DATA6       PIN_D6
.................... #define LCD_DATA7       PIN_D7 
.................... 
.................... #include <input.c>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                             input.c                               ////
.................... ////                                                                   ////
.................... //// Routines for reading user input over an RS232 stream.  User input ////
.................... //// is in ASCII form and converted to requested binary or float       ////
.................... //// format.                                                           ////
.................... ////                                                                   ////
.................... //// If STREAM_SERIAL_INPUT is defined, these routines will read from  ////
.................... //// that serial stream.  If not, uses the last #use rs232().          ////
.................... ////                                                                   ////
.................... //// Some of these routines are not available unless you #include      ////
.................... //// string.h and stdlib.h                                             ////
.................... ////                                                                   ////
.................... ////  int8 gethex() - read 2 char hex value from serial                ////
.................... ////                                                                   ////
.................... ////  get_string(s, max) - read max chars from serial and save to s    ////
.................... ////                                                                   ////
.................... ////  get_stringEdit(s, max) - similar to get_string(), but first it   ////
.................... ////     displays current string in s, allowing you to edit it.        ////
.................... ////                                                                   ////
.................... ////  int8 = get_Int8() -                                              ////
.................... ////  int16 = get_Int16() -                                            ////
.................... ////  int32 = get_Int32() -                                            ////
.................... ////  float = get_float() -                                            ////
.................... ////     Read value from serial.                                       ////
.................... ////                                                                   ////
.................... ////  int8 = get_Int8Edit(old) -                                       ////
.................... ////  int16 = get_Int16Edit(old) -                                     ////
.................... ////  int32 = get_Int32Edit(old) -                                     ////
.................... ////  float = get_floatEdit(old) -                                     ////
.................... ////     Similar to get_Int*() routines documented above, but first    ////
.................... ////     it displays old value allowing you to edit it.                ////
.................... ////                                                                   ////
.................... ////  int = get_int() -                                                ////
.................... ////  long = get_long() -                                              ////
.................... ////     Simlar to get_Int*() documented above, but return 'int' and   ////
.................... ////     'long' datatypes.  The size of these datatypes depends on     ////
.................... ////     the PIC architecture and compiler configuration.              ////
.................... ////                                                                   ////
.................... ////  int = get_intEdit(old) -                                         ////
.................... ////  long = get_longEdit(old) -                                       ////
.................... ////     Similar to get_int() and get_long() documented above,         ////
.................... ////     but first it displays old value allowing you to edit it.      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __INPUT_C__
.................... #define __INPUT_C__
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #ifndef InputKbhit
....................    #if defined(STREAM_SERIAL_INPUT)
....................       #define InputKbhit()    kbhit(STREAM_SERIAL_INPUT)
....................    #else
....................       #define InputKbhit()    kbhit()
....................    #endif
.................... #endif
.................... 
.................... #if !definedinc(InputPutc)
....................    #if defined(STREAM_SERIAL_INPUT)
....................       void InputPutc(char c)    {fputc(c, STREAM_SERIAL_INPUT);}
....................    #else
....................       void InputPutc(char c)    {putc(c);}
00CFA:  MOVF   x64,W
00CFC:  BRA    0CF0
00CFE:  RETURN 0
....................    #endif
.................... #endif
.................... 
.................... #ifndef InputGetc
....................    #if defined(STREAM_SERIAL_INPUT)
....................       #define InputGetc()    fgetc(STREAM_SERIAL_INPUT)
....................    #else
....................       #define InputGetc()    getc()
....................    #endif
.................... #endif
.................... 
.................... unsigned int8 gethex1() {
....................    char digit;
.................... 
....................    digit = InputGetc();
.................... 
....................    InputPutc(digit);
.................... 
....................    if(digit<='9')
....................      return(digit-'0');
....................    else
....................      return((toupper(digit)-'A')+10);
.................... }
.................... 
.................... unsigned int8 gethex() {
....................    unsigned int8 lo,hi;
.................... 
....................    hi = gethex1();
....................    lo = gethex1();
....................    if(lo==0xdd)
....................      return(hi);
....................    else
....................      return( hi*16+lo );
.................... }
.................... 
.................... void get_string(char* s, unsigned int8 max) {
....................    unsigned int8 len;
....................    char c;
.................... 
....................    max-=2;
00D00:  MOVLW  02
00D02:  SUBWF  x61,F
....................    len=0;
00D04:  CLRF   x62
....................    do {
....................      c=InputGetc();
00D06:  BTFSS  F9E.5
00D08:  BRA    0D06
00D0A:  MOVFF  FAE,63
....................      if(c==8) {  // Backspace
00D0E:  MOVF   x63,W
00D10:  SUBLW  08
00D12:  BNZ   0D2E
....................         if(len>0) {
00D14:  MOVF   x62,F
00D16:  BZ    0D2C
....................           len--;
00D18:  DECF   x62,F
....................           InputPutc(c);
00D1A:  MOVFF  63,64
00D1E:  RCALL  0CFA
....................           InputPutc(' ');
00D20:  MOVLW  20
00D22:  MOVWF  x64
00D24:  RCALL  0CFA
....................           InputPutc(c);
00D26:  MOVFF  63,64
00D2A:  RCALL  0CFA
....................         }
....................      } else if ((c>=' ')&&(c<='~'))
00D2C:  BRA    0D58
00D2E:  MOVF   x63,W
00D30:  SUBLW  1F
00D32:  BC    0D58
00D34:  MOVF   x63,W
00D36:  SUBLW  7E
00D38:  BNC   0D58
....................        if(len<=max) {
00D3A:  MOVF   x62,W
00D3C:  SUBWF  x61,W
00D3E:  BNC   0D58
....................          s[len++]=c;
00D40:  MOVF   x62,W
00D42:  INCF   x62,F
00D44:  ADDWF  5F,W
00D46:  MOVWF  FE9
00D48:  MOVLW  00
00D4A:  ADDWFC x60,W
00D4C:  MOVWF  FEA
00D4E:  MOVFF  63,FEF
....................          InputPutc(c);
00D52:  MOVFF  63,64
00D56:  RCALL  0CFA
....................        }
....................    } while(c!=13);
00D58:  MOVF   x63,W
00D5A:  SUBLW  0D
00D5C:  BNZ   0D06
....................    s[len]=0;
00D5E:  MOVF   x62,W
00D60:  ADDWF  5F,W
00D62:  MOVWF  FE9
00D64:  MOVLW  00
00D66:  ADDWFC x60,W
00D68:  MOVWF  FEA
00D6A:  CLRF   FEF
00D6C:  GOTO   13A0 (RETURN)
.................... }
.................... 
.................... #ifdef _STRING
.................... void get_stringEdit(char* s, unsigned int8 max) {
....................    unsigned int8 len;
....................    char c;
.................... 
....................    len = strlen(s);
.................... 
....................    if (len)
....................    {
....................      #if defined(STREAM_SERIAL_INPUT)
....................       fprintf(STREAM_SERIAL_INPUT, "%s", s);
....................      #else
....................       printf(InputPutc, "%s", s);
....................      #endif
....................    }
.................... 
....................    max-=2;
.................... 
....................    do {
....................      c=InputGetc();
....................      if(c==8) {  // Backspace
....................         if(len>0) {
....................           len--;
....................           InputPutc(c);
....................           InputPutc(' ');
....................           InputPutc(c);
....................         }
....................      } else if ((c>=' ')&&(c<='~'))
....................        if(len<=max) {
....................          s[len++]=c;
....................          InputPutc(c);
....................        }
....................    } while(c!=13);
....................    s[len]=0;
.................... }
.................... #endif
.................... 
.................... // stdlib.h is required for the ato_ conversions
.................... // in the following functions
.................... #ifdef _STDLIB
.................... signed int8 get_Int8(void)
.................... {
....................   char s[5];
....................   signed int8 i;
.................... 
....................   get_string(s, sizeof(s));
.................... 
....................   i=atoi(s);
....................   return(i);
.................... }
.................... 
.................... #ifdef _STRING
.................... signed int8 get_Int8Edit(signed int8 old)
.................... {
....................   char s[5];
....................   signed int8 i;
.................... 
....................   sprintf(s, "%d", old);
....................   get_stringEdit(s, sizeof(s));
.................... 
....................   i=atoi(s);
....................   return(i);
.................... }
.................... #endif
.................... 
.................... signed int16 get_Int16(void)
.................... {
....................   char s[7];
....................   signed int16 l;
.................... 
....................   get_string(s, sizeof(s));
....................   l=atol(s);
....................   return(l);
.................... }
.................... 
.................... #ifdef _STRING
.................... signed int16 get_Int16Edit(signed int16 old)
.................... {
....................   char s[7];
....................   signed int16 l;
.................... 
....................   sprintf(s, "%ld", old);
.................... 
....................   get_stringEdit(s, sizeof(s));
....................   l=atol(s);
....................   return(l);
.................... }
.................... #endif
.................... 
.................... signed int32 get_Int32(void)
.................... {
....................   char s[12];
....................   signed int32 l;
.................... 
....................   get_string(s, sizeof(s));
....................   l=atoi32(s);
....................   return(l);
.................... }
.................... 
.................... #ifdef _STRING
.................... signed int32 get_Int32Edit(signed int32 old)
.................... {
....................   char s[12];
....................   signed int32 l;
.................... 
....................   sprintf(s, "%ld", old);
.................... 
....................   get_stringEdit(s, sizeof(s));
....................   l=atoi32(s);
....................   return(l);
.................... }
.................... #endif
.................... 
.................... float get_float() {
....................   char s[20];
....................   float f;
.................... 
....................   get_string(s, 20);
....................   f = atof(s);
....................   return(f);
.................... }
.................... 
.................... #ifdef _STRING
.................... float get_floatEdit(float old) {
....................   char s[20];
....................   float f;
.................... 
....................   sprintf(s, "%f", old);
.................... 
....................   get_string(s, 20);
....................   f = atof(s);
....................   return(f);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
....................    #define get_int()       get_Int16()
....................    #define get_intEdit()   get_Int16Edit()
....................    #define get_long()      get_Int32()
....................    #define get_longEdit()  get_Int32Edit()
.................... #else
....................    #define get_int()       get_Int8()
....................    #define get_intEdit()   get_Int8Edit()
....................    #define get_long()      get_Int16()
....................    #define get_longEdit()  get_Int16Edit()
.................... #endif
.................... 
.................... #endif   //_STDLIB
.................... 
.................... #endif   //__INPUT_C__
.................... 
.................... #include <STDLIB.H>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
00D70:  MOVFF  94,97
....................    for(su=s;0<n;++su,--n)
00D74:  MOVFF  93,99
00D78:  MOVFF  92,98
00D7C:  MOVF   x96,F
00D7E:  BNZ   0D86
00D80:  MOVF   x95,W
00D82:  SUBLW  00
00D84:  BC    0DB2
....................       if(*su==uc)
00D86:  MOVFF  99,03
00D8A:  MOVFF  98,FE9
00D8E:  MOVFF  99,FEA
00D92:  MOVF   x97,W
00D94:  SUBWF  FEF,W
00D96:  BNZ   0DA2
....................       return su;
00D98:  MOVFF  98,01
00D9C:  MOVFF  99,02
00DA0:  BRA    0DB8
00DA2:  INCF   x98,F
00DA4:  BTFSC  FD8.2
00DA6:  INCF   x99,F
00DA8:  MOVF   x95,W
00DAA:  BTFSC  FD8.2
00DAC:  DECF   x96,F
00DAE:  DECF   x95,F
00DB0:  BRA    0D7C
....................    return NULL;
00DB2:  MOVLW  00
00DB4:  MOVWF  01
00DB6:  MOVWF  02
00DB8:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
....................    goto StrtoulGO;
.................... 
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(; sd!=0; )
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtoulGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
....................    }
....................    if (endptr)
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
*
00E0C:  CLRF   x6B
00E0E:  CLRF   x6A
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
00E10:  MOVLW  30
00E12:  MOVWF  x6D
00E14:  MOVLW  31
00E16:  MOVWF  x6E
00E18:  MOVLW  32
00E1A:  MOVWF  x6F
00E1C:  MOVLW  33
00E1E:  MOVWF  x70
00E20:  MOVLW  34
00E22:  MOVWF  x71
00E24:  MOVLW  35
00E26:  MOVWF  x72
00E28:  MOVLW  36
00E2A:  MOVWF  x73
00E2C:  MOVLW  37
00E2E:  MOVWF  x74
00E30:  MOVLW  38
00E32:  MOVWF  x75
00E34:  MOVLW  39
00E36:  MOVWF  x76
00E38:  MOVLW  61
00E3A:  MOVWF  x77
00E3C:  MOVLW  62
00E3E:  MOVWF  x78
00E40:  MOVLW  63
00E42:  MOVWF  x79
00E44:  MOVLW  64
00E46:  MOVWF  x7A
00E48:  MOVLW  65
00E4A:  MOVWF  x7B
00E4C:  MOVLW  66
00E4E:  MOVWF  x7C
00E50:  MOVLW  67
00E52:  MOVWF  x7D
00E54:  MOVLW  68
00E56:  MOVWF  x7E
00E58:  MOVLW  69
00E5A:  MOVWF  x7F
00E5C:  MOVLW  6A
00E5E:  MOVWF  x80
00E60:  MOVLW  6B
00E62:  MOVWF  x81
00E64:  MOVLW  6C
00E66:  MOVWF  x82
00E68:  MOVLW  6D
00E6A:  MOVWF  x83
00E6C:  MOVLW  6E
00E6E:  MOVWF  x84
00E70:  MOVLW  6F
00E72:  MOVWF  x85
00E74:  MOVLW  70
00E76:  MOVWF  x86
00E78:  MOVLW  71
00E7A:  MOVWF  x87
00E7C:  MOVLW  73
00E7E:  MOVWF  x88
00E80:  MOVLW  74
00E82:  MOVWF  x89
00E84:  MOVLW  75
00E86:  MOVWF  x8A
00E88:  MOVLW  76
00E8A:  MOVWF  x8B
00E8C:  MOVLW  77
00E8E:  MOVWF  x8C
00E90:  MOVLW  78
00E92:  MOVWF  x8D
00E94:  MOVLW  79
00E96:  MOVWF  x8E
00E98:  MOVLW  7A
00E9A:  MOVWF  x8F
00E9C:  CLRF   x90
....................    for(sc=s;isspace(*sc);++sc);
00E9E:  MOVFF  60,65
00EA2:  MOVFF  5F,64
00EA6:  MOVFF  65,03
00EAA:  MOVFF  64,FE9
00EAE:  MOVFF  65,FEA
00EB2:  MOVF   FEF,W
00EB4:  SUBLW  20
00EB6:  BNZ   0EC0
00EB8:  INCF   x64,F
00EBA:  BTFSC  FD8.2
00EBC:  INCF   x65,F
00EBE:  BRA    0EA6
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
00EC0:  MOVFF  65,03
00EC4:  MOVFF  64,FE9
00EC8:  MOVFF  65,FEA
00ECC:  MOVF   FEF,W
00ECE:  SUBLW  2D
00ED0:  BZ    0EE4
00ED2:  MOVFF  65,03
00ED6:  MOVFF  64,FE9
00EDA:  MOVFF  65,FEA
00EDE:  MOVF   FEF,W
00EE0:  SUBLW  2B
00EE2:  BNZ   0EF6
00EE4:  MOVFF  65,FEA
00EE8:  MOVF   x64,W
00EEA:  INCF   x64,F
00EEC:  BTFSC  FD8.2
00EEE:  INCF   x65,F
00EF0:  MOVWF  FE9
00EF2:  MOVF   FEF,W
00EF4:  BRA    0EF8
00EF6:  MOVLW  2B
00EF8:  MOVWF  x6C
....................    if (base <0 || base ==1|| base >36) // invalid base
00EFA:  BTFSC  x63.7
00EFC:  BRA    0F0E
00EFE:  DECFSZ x63,W
00F00:  BRA    0F04
00F02:  BRA    0F0E
00F04:  BTFSC  x63.7
00F06:  BRA    0F12
00F08:  MOVF   x63,W
00F0A:  SUBLW  24
00F0C:  BC    0F12
....................    goto StrtolGO;
00F0E:  BRA    1118
00F10:  BRA    101A
....................    else if (base)
00F12:  MOVF   x63,F
00F14:  BZ    0FAE
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
00F16:  MOVF   x63,W
00F18:  SUBLW  10
00F1A:  BNZ   0F5A
00F1C:  MOVFF  65,03
00F20:  MOVFF  64,FE9
00F24:  MOVFF  65,FEA
00F28:  MOVF   FEF,W
00F2A:  SUBLW  30
00F2C:  BNZ   0F5A
00F2E:  MOVLW  01
00F30:  ADDWF  x64,W
00F32:  MOVWF  FE9
00F34:  MOVLW  00
00F36:  ADDWFC x65,W
00F38:  MOVWF  FEA
00F3A:  MOVF   FEF,W
00F3C:  SUBLW  78
00F3E:  BZ    0F52
00F40:  MOVLW  01
00F42:  ADDWF  x64,W
00F44:  MOVWF  FE9
00F46:  MOVLW  00
00F48:  ADDWFC x65,W
00F4A:  MOVWF  FEA
00F4C:  MOVF   FEF,W
00F4E:  SUBLW  58
00F50:  BNZ   0F5A
....................          sc+=2;
00F52:  MOVLW  02
00F54:  ADDWF  x64,F
00F56:  MOVLW  00
00F58:  ADDWFC x65,F
....................       if(base==8 && *sc =='0')
00F5A:  MOVF   x63,W
00F5C:  SUBLW  08
00F5E:  BNZ   0F7A
00F60:  MOVFF  65,03
00F64:  MOVFF  64,FE9
00F68:  MOVFF  65,FEA
00F6C:  MOVF   FEF,W
00F6E:  SUBLW  30
00F70:  BNZ   0F7A
....................          sc+=1;
00F72:  MOVLW  01
00F74:  ADDWF  x64,F
00F76:  MOVLW  00
00F78:  ADDWFC x65,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
00F7A:  MOVF   x63,W
00F7C:  SUBLW  02
00F7E:  BNZ   0FAC
00F80:  MOVFF  65,03
00F84:  MOVFF  64,FE9
00F88:  MOVFF  65,FEA
00F8C:  MOVF   FEF,W
00F8E:  SUBLW  30
00F90:  BNZ   0FAC
00F92:  MOVLW  01
00F94:  ADDWF  x64,W
00F96:  MOVWF  FE9
00F98:  MOVLW  00
00F9A:  ADDWFC x65,W
00F9C:  MOVWF  FEA
00F9E:  MOVF   FEF,W
00FA0:  SUBLW  62
00FA2:  BNZ   0FAC
....................          sc+=2;
00FA4:  MOVLW  02
00FA6:  ADDWF  x64,F
00FA8:  MOVLW  00
00FAA:  ADDWFC x65,F
.................... 
....................    }
00FAC:  BRA    101A
....................    else if(*sc!='0') // base is 0, find base
00FAE:  MOVFF  65,03
00FB2:  MOVFF  64,FE9
00FB6:  MOVFF  65,FEA
00FBA:  MOVF   FEF,W
00FBC:  SUBLW  30
00FBE:  BZ    0FC6
....................       base=10;
00FC0:  MOVLW  0A
00FC2:  MOVWF  x63
00FC4:  BRA    101A
....................    else if (sc[1]=='x' || sc[1]=='X')
00FC6:  MOVLW  01
00FC8:  ADDWF  x64,W
00FCA:  MOVWF  FE9
00FCC:  MOVLW  00
00FCE:  ADDWFC x65,W
00FD0:  MOVWF  FEA
00FD2:  MOVF   FEF,W
00FD4:  SUBLW  78
00FD6:  BZ    0FEA
00FD8:  MOVLW  01
00FDA:  ADDWF  x64,W
00FDC:  MOVWF  FE9
00FDE:  MOVLW  00
00FE0:  ADDWFC x65,W
00FE2:  MOVWF  FEA
00FE4:  MOVF   FEF,W
00FE6:  SUBLW  58
00FE8:  BNZ   0FF8
....................       base =16,sc+=2;
00FEA:  MOVLW  10
00FEC:  MOVWF  x63
00FEE:  MOVLW  02
00FF0:  ADDWF  x64,F
00FF2:  MOVLW  00
00FF4:  ADDWFC x65,F
00FF6:  BRA    101A
....................    else if(sc[1]=='b')
00FF8:  MOVLW  01
00FFA:  ADDWF  x64,W
00FFC:  MOVWF  FE9
00FFE:  MOVLW  00
01000:  ADDWFC x65,W
01002:  MOVWF  FEA
01004:  MOVF   FEF,W
01006:  SUBLW  62
01008:  BNZ   1016
....................       base=2,sc+=2;
0100A:  MOVLW  02
0100C:  MOVWF  x63
0100E:  ADDWF  x64,F
01010:  MOVLW  00
01012:  ADDWFC x65,F
01014:  BRA    101A
....................    else
....................       base=8;
01016:  MOVLW  08
01018:  MOVWF  x63
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
0101A:  MOVFF  65,67
0101E:  MOVFF  64,66
01022:  MOVFF  65,03
01026:  MOVFF  64,FE9
0102A:  MOVFF  65,FEA
0102E:  MOVF   FEF,W
01030:  SUBLW  30
01032:  BNZ   103C
01034:  INCF   x64,F
01036:  BTFSC  FD8.2
01038:  INCF   x65,F
0103A:  BRA    1022
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
0103C:  MOVFF  65,03
01040:  MOVFF  64,FE9
01044:  MOVFF  65,FEA
01048:  MOVFF  FEF,91
0104C:  MOVF   x91,W
0104E:  SUBLW  40
01050:  BC    105E
01052:  MOVF   x91,W
01054:  SUBLW  5A
01056:  BNC   105E
01058:  MOVF   x91,W
0105A:  IORLW  20
0105C:  BRA    1060
0105E:  MOVF   x91,W
01060:  MOVWF  x91
01062:  CLRF   x93
01064:  MOVLW  6D
01066:  MOVWF  x92
01068:  MOVFF  91,94
0106C:  CLRF   x96
0106E:  MOVFF  63,95
01072:  BTFSC  x95.7
01074:  DECF   x96,F
01076:  RCALL  0D70
01078:  MOVFF  02,69
0107C:  MOVFF  01,68
....................    for(;sd!=0;)
01080:  MOVF   x68,F
01082:  BNZ   1088
01084:  MOVF   x69,F
01086:  BZ    110C
....................    {
....................       x=x*base+(int16)(sd-digits);
01088:  CLRF   03
0108A:  MOVF   x63,W
0108C:  MOVWF  00
0108E:  BTFSC  FE8.7
01090:  DECF   03,F
01092:  MOVWF  x91
01094:  MOVFF  03,92
01098:  MOVFF  6B,94
0109C:  MOVFF  6A,93
010A0:  MOVFF  03,96
010A4:  MOVWF  x95
010A6:  BRA    0DBA
010A8:  MOVLW  6D
010AA:  SUBWF  x68,W
010AC:  MOVWF  00
010AE:  MOVLW  00
010B0:  SUBWFB x69,W
010B2:  MOVWF  03
010B4:  MOVF   00,W
010B6:  ADDWF  01,W
010B8:  MOVWF  x6A
010BA:  MOVF   03,W
010BC:  ADDWFC 02,W
010BE:  MOVWF  x6B
....................       ++sc;
010C0:  INCF   x64,F
010C2:  BTFSC  FD8.2
010C4:  INCF   x65,F
....................       sd=memchr(digits,tolower(*sc),base);
010C6:  MOVFF  65,03
010CA:  MOVFF  64,FE9
010CE:  MOVFF  65,FEA
010D2:  MOVFF  FEF,91
010D6:  MOVF   x91,W
010D8:  SUBLW  40
010DA:  BC    10E8
010DC:  MOVF   x91,W
010DE:  SUBLW  5A
010E0:  BNC   10E8
010E2:  MOVF   x91,W
010E4:  IORLW  20
010E6:  BRA    10EA
010E8:  MOVF   x91,W
010EA:  MOVWF  x91
010EC:  CLRF   x93
010EE:  MOVLW  6D
010F0:  MOVWF  x92
010F2:  MOVFF  91,94
010F6:  CLRF   x96
010F8:  MOVFF  63,95
010FC:  BTFSC  x95.7
010FE:  DECF   x96,F
01100:  RCALL  0D70
01102:  MOVFF  02,69
01106:  MOVFF  01,68
0110A:  BRA    1080
....................    }
....................    if(s1==sc)
0110C:  MOVF   x64,W
0110E:  SUBWF  x66,W
01110:  BNZ   113A
01112:  MOVF   x65,W
01114:  SUBWF  x67,W
01116:  BNZ   113A
....................    {
....................    StrtolGO:
....................       if (endptr)
01118:  MOVLB  0
0111A:  MOVF   x61,W
0111C:  IORWF  x62,W
0111E:  BZ    1132
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
01120:  MOVFF  61,FE9
01124:  MOVFF  62,FEA
01128:  MOVFF  60,FEC
0112C:  MOVF   FED,F
0112E:  MOVFF  5F,FEF
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
01132:  MOVLW  00
01134:  MOVWF  01
01136:  MOVWF  02
01138:  BRA    116A
....................    }
....................    if(sign=='-')
0113A:  MOVF   x6C,W
0113C:  SUBLW  2D
0113E:  BNZ   114A
....................       x  =-x;
01140:  COMF   x6A,F
01142:  COMF   x6B,F
01144:  INCF   x6A,F
01146:  BTFSC  FD8.2
01148:  INCF   x6B,F
....................    if (endptr)
0114A:  MOVF   x61,W
0114C:  IORWF  x62,W
0114E:  BZ    1162
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
01150:  MOVFF  61,FE9
01154:  MOVFF  62,FEA
01158:  MOVFF  65,FEC
0115C:  MOVF   FED,F
0115E:  MOVFF  64,FEF
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
01162:  MOVFF  6A,01
01166:  MOVFF  6B,02
0116A:  GOTO   13B2 (RETURN)
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include <lcd.c>
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ////                             LCD.C                                     ////
.................... ////                 Driver for common LCD modules                         ////
.................... ////                                                                       ////
.................... ////  lcd_init()   Must be called before any other function.               ////
.................... ////                                                                       ////
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         ////
.................... ////                 \a  Set cursor position to upper left                 ////
.................... ////                 \f  Clear display, set cursor to upper left           ////
.................... ////                 \n  Go to start of second line                        ////
.................... ////                 \b  Move back one position                            ////
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     ////
.................... ////              will erase all remanining characters on the current      ////
.................... ////              line, and move the cursor to the beginning of the next   ////
.................... ////              line.                                                    ////
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     ////
.................... ////              will move the cursor to the start of the current         ////
.................... ////              line.                                                    ////
.................... ////                                                                       ////
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        ////
.................... ////                                                                       ////
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             ////
.................... ////                                                                       ////
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         ////
.................... ////              (on=FALSE).                                              ////
.................... ////                                                                       ////
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   ////
.................... ////                                                                       ////
.................... ////                                                                       ////
.................... ////  CONFIGURATION                                                        ////
.................... ////  The LCD can be configured in one of two ways: a.) port access or     ////
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     ////
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     ////
.................... ////  connected to sequential pins on the GPIO.  Pin access                ////
.................... ////  has no requirements, all 7 bits of the control interface can         ////
.................... ////  can be connected to any GPIO using several ports.                    ////
.................... ////                                                                       ////
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     ////
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    ////
.................... ////  of this file to configure the pin order.  If you are using a         ////
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  ////
.................... ////  be defined.                                                          ////
.................... ////                                                                       ////
.................... ////  Example of port access:                                              ////
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         ////
.................... ////                                                                       ////
.................... ////  To use pin access, the following pins must be defined:               ////
.................... ////     LCD_ENABLE_PIN                                                    ////
.................... ////     LCD_RS_PIN                                                        ////
.................... ////     LCD_RW_PIN                                                        ////
.................... ////     LCD_DATA4                                                         ////
.................... ////     LCD_DATA5                                                         ////
.................... ////     LCD_DATA6                                                         ////
.................... ////     LCD_DATA7                                                         ////
.................... ////                                                                       ////
.................... ////  Example of pin access:                                               ////
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    ////
.................... ////     #define LCD_RS_PIN      PIN_E1                                    ////
.................... ////     #define LCD_RW_PIN      PIN_E2                                    ////
.................... ////     #define LCD_DATA4       PIN_D4                                    ////
.................... ////     #define LCD_DATA5       PIN_D5                                    ////
.................... ////     #define LCD_DATA6       PIN_D6                                    ////
.................... ////     #define LCD_DATA7       PIN_D7                                    ////
.................... ////                                                                       ////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __LCD_C__
.................... #define __LCD_C__
.................... 
.................... // define the pinout.
.................... // only required if port access is being used.
.................... typedef struct  
.................... {                            // This structure is overlayed
....................    int1 enable;           // on to an I/O port to gain
....................    int1 rs;               // access to the LCD pins.
....................    int1 rw;               // The bits are allocated from
....................    int1 unused;           // low order up.  ENABLE will
....................    unsigned int     data : 4;         // be LSB pin of that port.
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT.
....................    unsigned int    reserved: 8;
....................   #endif
.................... } LCD_PIN_MAP;
.................... 
.................... // this is to improve compatability with previous LCD drivers that accepted
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B.
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE))
....................  #define LCD_DATA_PORT getenv("SFR:PORTB")
.................... #endif
.................... 
.................... #if defined(__PCB__)
....................    // these definitions only need to be modified for baseline PICs.
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions.
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0};
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF};
.................... #endif
.................... 
.................... ////////////////////// END CONFIGURATION ///////////////////////////////////
.................... 
.................... #ifndef LCD_ENABLE_PIN
....................    #define lcd_output_enable(x) lcdlat.enable=x
....................    #define lcd_enable_tris()   lcdtris.enable=0
.................... #else
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x)
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN)
.................... #endif
.................... 
.................... #ifndef LCD_RS_PIN
....................    #define lcd_output_rs(x) lcdlat.rs=x
....................    #define lcd_rs_tris()   lcdtris.rs=0
.................... #else
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x)
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN)
.................... #endif
.................... 
.................... #ifndef LCD_RW_PIN
....................    #define lcd_output_rw(x) lcdlat.rw=x
....................    #define lcd_rw_tris()   lcdtris.rw=0
.................... #else
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x)
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN)
.................... #endif
.................... 
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4,
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver
.................... // compatible with any code written for the original library
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7))
....................    #define  LCD_DATA4    LCD_DATA0
....................    #define  LCD_DATA5    LCD_DATA1
....................    #define  LCD_DATA6    LCD_DATA2
....................    #define  LCD_DATA7    LCD_DATA3
.................... #endif
.................... 
.................... #ifndef LCD_DATA4
.................... #ifndef LCD_DATA_PORT
....................    #if defined(__PCB__)
....................       #define LCD_DATA_PORT      0x06     //portb
....................       #define set_tris_lcd(x)   set_tris_b(x)
....................    #else
....................      #if defined(PIN_D0)
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd
....................      #else
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb
....................      #endif
....................    #endif   
.................... #endif
.................... 
.................... #if defined(__PCB__)
....................    LCD_PIN_MAP lcd, lcdlat;
....................    #byte lcd = LCD_DATA_PORT
....................    #byte lcdlat = LCD_DATA_PORT
.................... #elif defined(__PCM__)
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris;
....................    #byte lcd = LCD_DATA_PORT
....................    #byte lcdlat = LCD_DATA_PORT
....................    #byte lcdtris = LCD_DATA_PORT+0x80
.................... #elif defined(__PCH__)
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris;
....................    #byte lcd = LCD_DATA_PORT
....................    #byte lcdlat = LCD_DATA_PORT+9
....................    #byte lcdtris = LCD_DATA_PORT+0x12
.................... #elif defined(__PCD__)
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris;
....................    #word lcd = LCD_DATA_PORT
....................    #word lcdlat = LCD_DATA_PORT+2
....................    #word lcdtris = LCD_DATA_PORT-0x02
.................... #endif
.................... #endif   //LCD_DATA4 not defined
.................... 
.................... #ifndef LCD_TYPE
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines
.................... #endif
.................... 
.................... #ifndef LCD_LINE_TWO
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line
.................... #endif
.................... 
.................... #ifndef LCD_LINE_LENGTH
....................    #define LCD_LINE_LENGTH 20
.................... #endif
.................... 
.................... unsigned int8 lcd_read_nibble(void);
.................... 
.................... unsigned int8 lcd_read_byte(void)
.................... {
....................    unsigned int8 low,high;
.................... 
....................  #if defined(__PCB__)
....................    set_tris_lcd(LCD_INPUT_MAP);
....................  #else
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    output_float(LCD_DATA4);
*
00382:  BSF    F95.4
....................    output_float(LCD_DATA5);
00384:  BSF    F95.5
....................    output_float(LCD_DATA6);
00386:  BSF    F95.6
....................    output_float(LCD_DATA7);
00388:  BSF    F95.7
....................   #else
....................    lcdtris.data = 0xF;
....................   #endif
....................  #endif
....................         
....................    lcd_output_rw(1);
0038A:  BSF    F8D.2
0038C:  BCF    F96.2
....................    delay_cycles(1);
0038E:  NOP   
....................    lcd_output_enable(1);
00390:  BSF    F8D.1
00392:  BCF    F96.1
....................    delay_cycles(1);
00394:  NOP   
....................    high = lcd_read_nibble();
00396:  RCALL  0330
00398:  MOVFF  01,B0
....................       
....................    lcd_output_enable(0);
0039C:  BCF    F8D.1
0039E:  BCF    F96.1
....................    delay_cycles(1);
003A0:  NOP   
....................    lcd_output_enable(1);
003A2:  BSF    F8D.1
003A4:  BCF    F96.1
....................    delay_us(1);
003A6:  CLRWDT
003A8:  NOP   
....................    low = lcd_read_nibble();
003AA:  RCALL  0330
003AC:  MOVFF  01,AF
....................       
....................    lcd_output_enable(0);
003B0:  BCF    F8D.1
003B2:  BCF    F96.1
.................... 
....................  #if defined(__PCB__)
....................    set_tris_lcd(LCD_OUTPUT_MAP);
....................  #else
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    output_drive(LCD_DATA4);
003B4:  BCF    F95.4
....................    output_drive(LCD_DATA5);
003B6:  BCF    F95.5
....................    output_drive(LCD_DATA6);
003B8:  BCF    F95.6
....................    output_drive(LCD_DATA7);
003BA:  BCF    F95.7
....................   #else
....................    lcdtris.data = 0x0;
....................   #endif
....................  #endif
.................... 
....................    return( (high<<4) | low);
003BC:  SWAPF  xB0,W
003BE:  MOVWF  00
003C0:  MOVLW  F0
003C2:  ANDWF  00,F
003C4:  MOVF   00,W
003C6:  IORWF  xAF,W
003C8:  MOVWF  01
003CA:  RETURN 0
.................... }
.................... 
.................... unsigned int8 lcd_read_nibble(void)
.................... {
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
*
00330:  CLRF   xB1
....................    unsigned int8 n = 0x00;
.................... 
....................    /* Read the data port */
....................    n |= input(LCD_DATA4);
00332:  BSF    F95.4
00334:  MOVLW  00
00336:  BTFSC  F83.4
00338:  MOVLW  01
0033A:  IORWF  xB1,F
....................    n |= input(LCD_DATA5) << 1;
0033C:  BSF    F95.5
0033E:  MOVLW  00
00340:  BTFSC  F83.5
00342:  MOVLW  01
00344:  MOVWF  00
00346:  BCF    FD8.0
00348:  RLCF   00,F
0034A:  MOVF   00,W
0034C:  IORWF  xB1,F
....................    n |= input(LCD_DATA6) << 2;
0034E:  BSF    F95.6
00350:  MOVLW  00
00352:  BTFSC  F83.6
00354:  MOVLW  01
00356:  MOVWF  00
00358:  RLCF   00,F
0035A:  RLCF   00,F
0035C:  MOVLW  FC
0035E:  ANDWF  00,F
00360:  MOVF   00,W
00362:  IORWF  xB1,F
....................    n |= input(LCD_DATA7) << 3;
00364:  BSF    F95.7
00366:  MOVLW  00
00368:  BTFSC  F83.7
0036A:  MOVLW  01
0036C:  MOVWF  00
0036E:  RLCF   00,F
00370:  RLCF   00,F
00372:  RLCF   00,F
00374:  MOVLW  F8
00376:  ANDWF  00,F
00378:  MOVF   00,W
0037A:  IORWF  xB1,F
....................    
....................    return(n);
0037C:  MOVFF  B1,01
....................   #else
00380:  RETURN 0
....................    return(lcd.data);
....................   #endif
.................... }
.................... 
.................... void lcd_send_nibble(unsigned int8 n)
.................... {
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    /* Write to the data port */
....................    output_bit(LCD_DATA4, bit_test(n, 0));
*
003CC:  BTFSC  xB0.0
003CE:  BRA    03D4
003D0:  BCF    F8C.4
003D2:  BRA    03D6
003D4:  BSF    F8C.4
003D6:  BCF    F95.4
....................    output_bit(LCD_DATA5, bit_test(n, 1));
003D8:  BTFSC  xB0.1
003DA:  BRA    03E0
003DC:  BCF    F8C.5
003DE:  BRA    03E2
003E0:  BSF    F8C.5
003E2:  BCF    F95.5
....................    output_bit(LCD_DATA6, bit_test(n, 2));
003E4:  BTFSC  xB0.2
003E6:  BRA    03EC
003E8:  BCF    F8C.6
003EA:  BRA    03EE
003EC:  BSF    F8C.6
003EE:  BCF    F95.6
....................    output_bit(LCD_DATA7, bit_test(n, 3));
003F0:  BTFSC  xB0.3
003F2:  BRA    03F8
003F4:  BCF    F8C.7
003F6:  BRA    03FA
003F8:  BSF    F8C.7
003FA:  BCF    F95.7
....................   #else      
....................    lcdlat.data = n;
....................   #endif
....................       
....................    delay_cycles(1);
003FC:  NOP   
....................    lcd_output_enable(1);
003FE:  BSF    F8D.1
00400:  BCF    F96.1
....................    delay_us(2);
00402:  CLRWDT
00404:  BRA    0406
00406:  NOP   
....................    lcd_output_enable(0);
00408:  BCF    F8D.1
0040A:  BCF    F96.1
0040C:  RETURN 0
.................... }
.................... 
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n)
.................... {
....................   #if defined(__PCB__)
....................    set_tris_lcd(LCD_OUTPUT_MAP);
....................   #else
....................    lcd_enable_tris();
0040E:  BCF    F96.1
....................    lcd_rs_tris();
00410:  BCF    F96.0
....................    lcd_rw_tris();
00412:  BCF    F96.2
....................   #endif
.................... 
....................    lcd_output_rs(0);
00414:  BCF    F8D.0
00416:  BCF    F96.0
....................    while ( bit_test(lcd_read_byte(),7) ) ;
00418:  RCALL  0382
0041A:  MOVFF  01,AF
0041E:  BTFSC  01.7
00420:  BRA    0418
....................    lcd_output_rs(address);
00422:  MOVF   xAD,F
00424:  BNZ   042A
00426:  BCF    F8D.0
00428:  BRA    042C
0042A:  BSF    F8D.0
0042C:  BCF    F96.0
....................    delay_cycles(1);
0042E:  NOP   
....................    lcd_output_rw(0);
00430:  BCF    F8D.2
00432:  BCF    F96.2
....................    delay_cycles(1);
00434:  NOP   
....................    lcd_output_enable(0);
00436:  BCF    F8D.1
00438:  BCF    F96.1
....................    lcd_send_nibble(n >> 4);
0043A:  SWAPF  xAE,W
0043C:  MOVWF  xAF
0043E:  MOVLW  0F
00440:  ANDWF  xAF,F
00442:  MOVFF  AF,B0
00446:  RCALL  03CC
....................    lcd_send_nibble(n & 0xf);
00448:  MOVF   xAE,W
0044A:  ANDLW  0F
0044C:  MOVWF  xAF
0044E:  MOVWF  xB0
00450:  RCALL  03CC
00452:  RETURN 0
.................... }
.................... 
.................... #if defined(LCD_EXTENDED_NEWLINE)
.................... unsigned int8 g_LcdX, g_LcdY;
.................... #endif
.................... 
.................... void lcd_init(void) 
.................... {
....................    unsigned int8 i;
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6};
*
00C04:  MOVLW  28
00C06:  MOVWF  x60
00C08:  MOVLW  0C
00C0A:  MOVWF  x61
00C0C:  MOVLW  01
00C0E:  MOVWF  x62
00C10:  MOVLW  06
00C12:  MOVWF  x63
....................                              // These bytes need to be sent to the LCD
....................                              // to start it up.
....................    
.................... 
....................    lcd_output_enable(0);
00C14:  BCF    F8D.1
00C16:  BCF    F96.1
....................    lcd_output_rs(0);
00C18:  BCF    F8D.0
00C1A:  BCF    F96.0
....................    lcd_output_rw(0);
00C1C:  BCF    F8D.2
00C1E:  BCF    F96.2
.................... 
....................  #if defined(__PCB__)
....................    set_tris_lcd(LCD_OUTPUT_MAP);
....................  #else
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    output_drive(LCD_DATA4);
00C20:  BCF    F95.4
....................    output_drive(LCD_DATA5);
00C22:  BCF    F95.5
....................    output_drive(LCD_DATA6);
00C24:  BCF    F95.6
....................    output_drive(LCD_DATA7);
00C26:  BCF    F95.7
....................   #else
....................    lcdtris.data = 0x0;
....................   #endif
....................    lcd_enable_tris();
00C28:  BCF    F96.1
....................    lcd_rs_tris();
00C2A:  BCF    F96.0
....................    lcd_rw_tris();
00C2C:  BCF    F96.2
00C2E:  CLRF   19
00C30:  BTFSC  FF2.7
00C32:  BSF    19.7
00C34:  BCF    FF2.7
....................  #endif
....................     
....................    delay_ms(15);
00C36:  MOVLW  0F
00C38:  MOVWF  xA9
00C3A:  RCALL  0542
00C3C:  BTFSC  19.7
00C3E:  BSF    FF2.7
....................    for(i=1;i<=3;++i)
00C40:  MOVLW  01
00C42:  MOVWF  5F
00C44:  MOVF   5F,W
00C46:  SUBLW  03
00C48:  BNC   0C74
00C4A:  CLRF   19
00C4C:  BTFSC  FF2.7
00C4E:  BSF    19.7
00C50:  BCF    FF2.7
....................    {
....................        lcd_send_nibble(3);
00C52:  MOVLW  03
00C54:  MOVWF  xB0
00C56:  CALL   03CC
00C5A:  BTFSC  19.7
00C5C:  BSF    FF2.7
00C5E:  CLRF   19
00C60:  BTFSC  FF2.7
00C62:  BSF    19.7
00C64:  BCF    FF2.7
....................        delay_ms(5);
00C66:  MOVLW  05
00C68:  MOVWF  xA9
00C6A:  RCALL  0542
00C6C:  BTFSC  19.7
00C6E:  BSF    FF2.7
00C70:  INCF   5F,F
00C72:  BRA    0C44
00C74:  CLRF   19
00C76:  BTFSC  FF2.7
00C78:  BSF    19.7
00C7A:  BCF    FF2.7
....................    }
....................    
....................    lcd_send_nibble(2);
00C7C:  MOVLW  02
00C7E:  MOVWF  xB0
00C80:  CALL   03CC
00C84:  BTFSC  19.7
00C86:  BSF    FF2.7
00C88:  CLRF   19
00C8A:  BTFSC  FF2.7
00C8C:  BSF    19.7
00C8E:  BCF    FF2.7
....................    delay_ms(5);
00C90:  MOVLW  05
00C92:  MOVWF  xA9
00C94:  RCALL  0542
00C96:  BTFSC  19.7
00C98:  BSF    FF2.7
....................    for(i=0;i<=3;++i)
00C9A:  CLRF   5F
00C9C:  MOVF   5F,W
00C9E:  SUBLW  03
00CA0:  BNC   0CCA
....................       lcd_send_byte(0,LCD_INIT_STRING[i]);
00CA2:  CLRF   03
00CA4:  MOVF   5F,W
00CA6:  ADDLW  60
00CA8:  MOVWF  FE9
00CAA:  MOVLW  00
00CAC:  ADDWFC 03,W
00CAE:  MOVWF  FEA
00CB0:  CLRF   19
00CB2:  BTFSC  FF2.7
00CB4:  BSF    19.7
00CB6:  BCF    FF2.7
00CB8:  MOVFF  FEF,AE
00CBC:  CLRF   xAD
00CBE:  CALL   040E
00CC2:  BTFSC  19.7
00CC4:  BSF    FF2.7
.................... 
....................   #if defined(LCD_EXTENDED_NEWLINE)
00CC6:  INCF   5F,F
00CC8:  BRA    0C9C
00CCA:  GOTO   12D4 (RETURN)
....................    g_LcdX = 0;
....................    g_LcdY = 0;
....................   #endif
.................... }
.................... 
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y)
.................... {
....................    unsigned int8 address;
....................    
....................    if(y!=1)
*
00454:  DECFSZ xAA,W
00456:  BRA    045A
00458:  BRA    0460
....................       address=LCD_LINE_TWO;
0045A:  MOVLW  40
0045C:  MOVWF  xAB
0045E:  BRA    0462
....................    else
....................       address=0;
00460:  CLRF   xAB
....................      
....................    address+=x-1;
00462:  MOVLW  01
00464:  SUBWF  xA9,W
00466:  ADDWF  xAB,F
....................    lcd_send_byte(0,0x80|address);
00468:  MOVF   xAB,W
0046A:  IORLW  80
0046C:  MOVWF  xAC
0046E:  CLRF   xAD
00470:  MOVWF  xAE
00472:  RCALL  040E
.................... 
....................   #if defined(LCD_EXTENDED_NEWLINE)
00474:  RETURN 0
....................    g_LcdX = x - 1;
....................    g_LcdY = y - 1;
....................   #endif
.................... }
.................... 
.................... void lcd_putc(char c)
.................... {
....................    switch (c)
*
00570:  MOVF   xA8,W
00572:  XORLW  07
00574:  BZ    0584
00576:  XORLW  0B
00578:  BZ    058E
0057A:  XORLW  06
0057C:  BZ    059E
0057E:  XORLW  02
00580:  BZ    05AA
00582:  BRA    05B4
....................    {
....................       case '\a'   :  lcd_gotoxy(1,1);     break;
00584:  MOVLW  01
00586:  MOVWF  xA9
00588:  MOVWF  xAA
0058A:  RCALL  0454
0058C:  BRA    05BE
.................... 
....................       case '\f'   :  lcd_send_byte(0,1);
0058E:  CLRF   xAD
00590:  MOVLW  01
00592:  MOVWF  xAE
00594:  RCALL  040E
....................                      delay_ms(2);
00596:  MOVLW  02
00598:  MOVWF  xA9
0059A:  RCALL  0542
....................                     #if defined(LCD_EXTENDED_NEWLINE)
....................                      g_LcdX = 0;
....................                      g_LcdY = 0;
....................                     #endif
....................                      break;
0059C:  BRA    05BE
.................... 
....................      #if defined(LCD_EXTENDED_NEWLINE)
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break;
....................       case '\n'   :
....................          while (g_LcdX++ < LCD_LINE_LENGTH)
....................          {
....................             lcd_send_byte(1, ' ');
....................          }
....................          lcd_gotoxy(1, g_LcdY+2);
....................          break;
....................      #else
....................       case '\n'   : lcd_gotoxy(1,2);        break;
0059E:  MOVLW  01
005A0:  MOVWF  xA9
005A2:  MOVLW  02
005A4:  MOVWF  xAA
005A6:  RCALL  0454
005A8:  BRA    05BE
....................      #endif
....................      
....................       case '\b'   : lcd_send_byte(0,0x10);  break;
005AA:  CLRF   xAD
005AC:  MOVLW  10
005AE:  MOVWF  xAE
005B0:  RCALL  040E
005B2:  BRA    05BE
....................      
....................      #if defined(LCD_EXTENDED_NEWLINE)
....................       default     : 
....................          if (g_LcdX < LCD_LINE_LENGTH)
....................          {
....................             lcd_send_byte(1, c);
....................             g_LcdX++;
....................          }
....................          break;
....................      #else
....................       default     : lcd_send_byte(1,c);     break;
005B4:  MOVLW  01
005B6:  MOVWF  xAD
005B8:  MOVFF  A8,AE
005BC:  RCALL  040E
....................      #endif
....................    }
005BE:  RETURN 0
.................... }
....................  
.................... char lcd_getc(unsigned int8 x, unsigned int8 y)
.................... {
....................    char value;
.................... 
....................    lcd_gotoxy(x,y);
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low
....................    lcd_output_rs(1);
....................    value = lcd_read_byte();
....................    lcd_output_rs(0);
....................    
....................    return(value);
.................... }
.................... 
.................... // write a custom character to the ram
.................... // which is 0-7 and specifies which character array we are modifying.
.................... // ptr points to an array of 8 bytes, where each byte is the next row of
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and
.................... //    usually you will want to leave this byte 0x00.
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr)
.................... {
....................    unsigned int i;
.................... 
....................    which <<= 3;
....................    which &= 0x38;
.................... 
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address
.................... 
....................    for(i=0; i<8; i++)
....................    {
....................       lcd_send_byte(1, *ptr++);
....................    }
....................   
....................    #if defined(LCD_EXTENDED_NEWLINE)
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address
....................    #endif
.................... }
.................... 
.................... void lcd_cursor_on(int1 on)
.................... {
....................    if (on)
....................    {
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON
....................    }
....................    else
....................    {
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF
....................    }
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... //#include "gets_timeout.c"
.................... char mystring[20]="    ";
.................... char fim_mystring[15]="    ";
.................... char *ponteiro;
.................... int16 angulo_inteiro;
.................... float angulo;
.................... float angulo_flutuante;
.................... 
.................... float valor;
.................... int16 duty;
.................... float tensao=5.35;
....................   
.................... int16 servo1_cmd;
.................... int16 servo2_cmd;  
....................    
.................... #define max 4
.................... 
.................... #INT_TIMER1
.................... void  TIMER1_isr(void) 
.................... {
.................... valor= read_adc();     
*
00A16:  BSF    FC2.1
00A18:  BTFSC  FC2.1
00A1A:  BRA    0A18
00A1C:  MOVFF  FC4,02
00A20:  MOVFF  FC3,01
00A24:  MOVFF  FC4,03
00A28:  MOVFF  FC3,9B
00A2C:  MOVFF  FC4,9C
00A30:  CALL   00AE
00A34:  MOVFF  03,52
00A38:  MOVFF  02,51
00A3C:  MOVFF  01,50
00A40:  MOVFF  00,4F
.................... delay_us(100); 
00A44:  CLRWDT
00A46:  MOVLW  42
00A48:  MOVWF  00
00A4A:  DECFSZ 00,F
00A4C:  BRA    0A4A
.................... tensao= (valor*5) /1024;
00A4E:  MOVFF  52,AB
00A52:  MOVFF  51,AA
00A56:  MOVFF  50,A9
00A5A:  MOVFF  4F,A8
00A5E:  CLRF   xAF
00A60:  CLRF   xAE
00A62:  MOVLW  20
00A64:  MOVWF  xAD
00A66:  MOVLW  81
00A68:  MOVWF  xAC
00A6A:  CALL   00E4
00A6E:  MOVFF  03,9E
00A72:  MOVFF  02,9D
00A76:  MOVFF  01,9C
00A7A:  MOVFF  00,9B
00A7E:  MOVFF  03,A2
00A82:  MOVFF  02,A1
00A86:  MOVFF  01,A0
00A8A:  MOVFF  00,9F
00A8E:  CLRF   xA6
00A90:  CLRF   xA5
00A92:  CLRF   xA4
00A94:  MOVLW  89
00A96:  MOVWF  xA3
00A98:  CALL   01D6
00A9C:  MOVFF  03,58
00AA0:  MOVFF  02,57
00AA4:  MOVFF  01,56
00AA8:  MOVFF  00,55
.................... lcd_gotoxy(1,2); //Posicina o LCD na segunda linha e primeiro caracter
00AAC:  MOVLW  01
00AAE:  MOVWF  xA9
00AB0:  MOVLW  02
00AB2:  MOVWF  xAA
00AB4:  RCALL  0454
.................... printf(LCD_PUTC,"%2.2f volts     ",tensao);
00AB6:  MOVLW  89
00AB8:  MOVWF  FE9
00ABA:  MOVFF  58,9E
00ABE:  MOVFF  57,9D
00AC2:  MOVFF  56,9C
00AC6:  MOVFF  55,9B
00ACA:  MOVLW  02
00ACC:  MOVWF  x9F
00ACE:  RCALL  05C0
00AD0:  MOVLW  87
00AD2:  MOVWF  FF6
00AD4:  MOVLW  0B
00AD6:  MOVWF  FF7
00AD8:  MOVLW  0B
00ADA:  MOVWF  x9B
00ADC:  RCALL  0738
.................... 
.................... servo2_cmd= 1000 + valor/1.024;
00ADE:  MOVFF  52,A2
00AE2:  MOVFF  51,A1
00AE6:  MOVFF  50,A0
00AEA:  MOVFF  4F,9F
00AEE:  MOVLW  6F
00AF0:  MOVWF  xA6
00AF2:  MOVLW  12
00AF4:  MOVWF  xA5
00AF6:  MOVLW  03
00AF8:  MOVWF  xA4
00AFA:  MOVLW  7F
00AFC:  MOVWF  xA3
00AFE:  CALL   01D6
00B02:  BCF    FD8.1
00B04:  CLRF   x9E
00B06:  CLRF   x9D
00B08:  MOVLW  7A
00B0A:  MOVWF  x9C
00B0C:  MOVLW  88
00B0E:  MOVWF  x9B
00B10:  MOVFF  03,A2
00B14:  MOVFF  02,A1
00B18:  MOVFF  01,A0
00B1C:  MOVFF  00,9F
00B20:  RCALL  0756
00B22:  MOVFF  03,9E
00B26:  MOVFF  02,9D
00B2A:  MOVFF  01,9C
00B2E:  MOVFF  00,9B
00B32:  RCALL  09C0
00B34:  MOVFF  02,5C
00B38:  MOVFF  01,5B
.................... 
.................... output_high(PIN_C5);
00B3C:  BCF    F94.5
00B3E:  BSF    F8B.5
.................... delay_us(servo2_cmd);// comando dos SERVO 2
00B40:  MOVFF  5C,9B
00B44:  INCF   x9B,F
00B46:  DECF   x9B,F
00B48:  BTFSC  FD8.2
00B4A:  BRA    0B52
00B4C:  SETF   x9C
00B4E:  RCALL  09F8
00B50:  BRA    0B46
00B52:  MOVFF  5B,9C
00B56:  RCALL  09F8
.................... output_low(PIN_C5);
00B58:  BCF    F94.5
00B5A:  BCF    F8B.5
.................... 
.................... output_high(PIN_C4);
00B5C:  BCF    F94.4
00B5E:  BSF    F8B.4
.................... delay_us(servo1_cmd); // comando dos SERVO 1
00B60:  MOVFF  5A,9B
00B64:  INCF   x9B,F
00B66:  DECF   x9B,F
00B68:  BTFSC  FD8.2
00B6A:  BRA    0B72
00B6C:  SETF   x9C
00B6E:  RCALL  09F8
00B70:  BRA    0B66
00B72:  MOVFF  59,9C
00B76:  RCALL  09F8
.................... output_low(PIN_C4);
00B78:  BCF    F94.4
00B7A:  BCF    F8B.4
00B7C:  BCF    F9E.0
00B7E:  GOTO   0060
.................... }
.................... 
.................... void main()
*
0123E:  CLRF   FF8
01240:  BCF    FD0.7
01242:  BSF    07.7
01244:  MOVLW  60
01246:  MOVWF  FD3
01248:  BCF    F9B.6
0124A:  BCF    F9B.7
0124C:  BCF    FB8.3
0124E:  MOVLW  0C
01250:  MOVWF  FAF
01252:  MOVLW  A2
01254:  MOVWF  FAC
01256:  MOVLW  90
01258:  MOVWF  FAB
0125A:  MOVLW  33
0125C:  MOVWF  58
0125E:  MOVWF  57
01260:  MOVLW  2B
01262:  MOVWF  56
01264:  MOVLW  81
01266:  MOVWF  55
01268:  CLRF   5E
0126A:  CLRF   5D
0126C:  MOVLB  F
0126E:  CLRF   x38
01270:  CLRF   x39
01272:  CLRF   x3A
01274:  CLRF   x3B
01276:  CLRF   x3C
01278:  CLRF   F77
0127A:  CLRF   F78
0127C:  CLRF   F79
0127E:  CLRF   1A
01280:  CLRF   1B
01282:  MOVLW  20
01284:  MOVWF  20
01286:  MOVWF  21
01288:  MOVWF  22
0128A:  MOVWF  23
0128C:  CLRF   24
0128E:  MOVWF  34
01290:  MOVWF  35
01292:  MOVWF  36
01294:  MOVWF  37
01296:  CLRF   38
.................... {
....................    setup_adc(ADC_CLOCK_INTERNAL); 
01298:  MOVF   FC0,W
0129A:  ANDLW  C0
0129C:  IORLW  07
0129E:  MOVWF  FC0
012A0:  BSF    FC0.7
012A2:  BSF    FC2.0
....................    setup_adc_ports(sAN0);
012A4:  MOVF   FC1,W
012A6:  ANDLW  F0
012A8:  MOVWF  FC1
012AA:  MOVLW  01
012AC:  MOVWF  x38
012AE:  MOVLW  00
012B0:  MOVWF  x3C
012B2:  MOVWF  x39
012B4:  MOVWF  x3A
012B6:  MOVWF  x3B
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_1); // 1/2MHz * 65636 = 32,7 ms overflow
012B8:  MOVLW  07
012BA:  MOVWF  FCD
012BC:  CLRF   FCC
.................... 
....................    enable_interrupts(INT_TIMER1);
012BE:  BSF    F9D.0
....................    enable_interrupts(GLOBAL);
012C0:  MOVLW  C0
012C2:  IORWF  FF2,F
....................    
....................    
....................    set_adc_channel(0); 
012C4:  MOVLW  00
012C6:  MOVWF  01
012C8:  MOVF   FC2,W
012CA:  ANDLW  83
012CC:  IORWF  01,W
012CE:  MOVWF  FC2
.................... 
.................... lcd_init();
012D0:  MOVLB  0
012D2:  BRA    0C04
.................... printf("Projeto  SERVO\n\r");    valor= read_adc();
012D4:  MOVLW  94
012D6:  MOVWF  FF6
012D8:  MOVLW  0B
012DA:  MOVWF  FF7
012DC:  RCALL  0CCE
012DE:  BSF    FC2.1
012E0:  BTFSC  FC2.1
012E2:  BRA    12E0
012E4:  MOVFF  FC4,02
012E8:  MOVFF  FC3,01
012EC:  MOVFF  FC4,03
012F0:  MOVF   FC3,W
012F2:  CLRF   19
012F4:  BTFSC  FF2.7
012F6:  BSF    19.7
012F8:  BCF    FF2.7
012FA:  MOVWF  x9B
012FC:  MOVFF  FC4,9C
01300:  CALL   00AE
01304:  BTFSC  19.7
01306:  BSF    FF2.7
01308:  MOVFF  03,52
0130C:  MOVFF  02,51
01310:  MOVFF  01,50
01314:  MOVFF  00,4F
01318:  CLRF   19
0131A:  BTFSC  FF2.7
0131C:  BSF    19.7
0131E:  BCF    FF2.7
.................... //duty= valor*1000/1024;
.................... //delay_us(100); 
.................... //tensao= (valor*5) /1024;   
.................... lcd_gotoxy(1,2); //Posicina o LCD na segunda linha e primeiro caracter
01320:  MOVLW  01
01322:  MOVWF  xA9
01324:  MOVLW  02
01326:  MOVWF  xAA
01328:  CALL   0454
0132C:  BTFSC  19.7
0132E:  BSF    FF2.7
.................... printf(LCD_PUTC,"%2.2f volts     ",tensao);
01330:  MOVLW  89
01332:  MOVWF  FE9
01334:  CLRF   19
01336:  BTFSC  FF2.7
01338:  BSF    19.7
0133A:  BCF    FF2.7
0133C:  MOVFF  58,9E
01340:  MOVFF  57,9D
01344:  MOVFF  56,9C
01348:  MOVFF  55,9B
0134C:  MOVLW  02
0134E:  MOVWF  x9F
01350:  CALL   05C0
01354:  BTFSC  19.7
01356:  BSF    FF2.7
01358:  MOVLW  AB
0135A:  MOVWF  FF6
0135C:  MOVLW  0B
0135E:  MOVWF  FF7
01360:  CLRF   19
01362:  BTFSC  FF2.7
01364:  BSF    19.7
01366:  BCF    FF2.7
01368:  MOVLW  0B
0136A:  MOVWF  x9B
0136C:  CALL   0738
01370:  BTFSC  19.7
01372:  BSF    FF2.7
01374:  CLRF   19
01376:  BTFSC  FF2.7
01378:  BSF    19.7
0137A:  BCF    FF2.7
.................... delay_ms(100); 
0137C:  MOVLW  64
0137E:  MOVWF  xA9
01380:  CALL   0542
01384:  BTFSC  19.7
01386:  BSF    FF2.7
.................... enable_interrupts(INT_TIMER1);
01388:  BSF    F9D.0
.................... 
....................    while(1){  
....................    
....................       printf("\n\rDigite o angulo do servo entre  0 e 180 graus:\r\n");  // hang till input unless TIMEOUT used
0138A:  MOVLW  B8
0138C:  MOVWF  FF6
0138E:  MOVLW  0B
01390:  MOVWF  FF7
01392:  RCALL  0CCE
....................       //gets_timeout(mystring,5); 
....................       get_string(mystring, max);
01394:  CLRF   x60
01396:  MOVLW  20
01398:  MOVWF  5F
0139A:  MOVLW  04
0139C:  MOVWF  x61
0139E:  BRA    0D00
....................       angulo_inteiro=strtol(mystring, fim_mystring,10);
013A0:  CLRF   x60
013A2:  MOVLW  20
013A4:  MOVWF  5F
013A6:  CLRF   x62
013A8:  MOVLW  34
013AA:  MOVWF  x61
013AC:  MOVLW  0A
013AE:  MOVWF  x63
013B0:  BRA    0E0C
013B2:  MOVFF  02,46
013B6:  MOVFF  01,45
....................       printf("\n\rAngulo digitado=%LU\r\n",angulo_inteiro);           
013BA:  MOVLW  EC
013BC:  MOVWF  FF6
013BE:  MOVLW  0B
013C0:  MOVWF  FF7
013C2:  MOVLW  12
013C4:  MOVWF  5F
013C6:  BRA    116E
013C8:  MOVLW  10
013CA:  MOVWF  FE9
013CC:  MOVFF  46,60
013D0:  MOVFF  45,5F
013D4:  BRA    1190
013D6:  MOVLW  0D
013D8:  BTFSS  F9E.4
013DA:  BRA    13D8
013DC:  MOVWF  FAD
013DE:  MOVLW  0A
013E0:  BTFSS  F9E.4
013E2:  BRA    13E0
013E4:  MOVWF  FAD
013E6:  CLRF   19
013E8:  BTFSC  FF2.7
013EA:  BSF    19.7
013EC:  BCF    FF2.7
....................       servo1_cmd= 1000 + angulo_inteiro*5.5555;
013EE:  MOVFF  46,9C
013F2:  MOVFF  45,9B
013F6:  CALL   00AE
013FA:  BTFSC  19.7
013FC:  BSF    FF2.7
013FE:  CLRF   19
01400:  BTFSC  FF2.7
01402:  BSF    19.7
01404:  BCF    FF2.7
01406:  MOVFF  03,AB
0140A:  MOVFF  02,AA
0140E:  MOVFF  01,A9
01412:  MOVFF  00,A8
01416:  MOVLW  A8
01418:  MOVWF  xAF
0141A:  MOVLW  C6
0141C:  MOVWF  xAE
0141E:  MOVLW  31
01420:  MOVWF  xAD
01422:  MOVLW  81
01424:  MOVWF  xAC
01426:  CALL   00E4
0142A:  BTFSC  19.7
0142C:  BSF    FF2.7
0142E:  BCF    FD8.1
01430:  CLRF   19
01432:  BTFSC  FF2.7
01434:  BSF    19.7
01436:  BCF    FF2.7
01438:  CLRF   x9E
0143A:  CLRF   x9D
0143C:  MOVLW  7A
0143E:  MOVWF  x9C
01440:  MOVLW  88
01442:  MOVWF  x9B
01444:  MOVFF  03,A2
01448:  MOVFF  02,A1
0144C:  MOVFF  01,A0
01450:  MOVFF  00,9F
01454:  CALL   0756
01458:  BTFSC  19.7
0145A:  BSF    FF2.7
0145C:  CLRF   19
0145E:  BTFSC  FF2.7
01460:  BSF    19.7
01462:  BCF    FF2.7
01464:  MOVFF  03,9E
01468:  MOVFF  02,9D
0146C:  MOVFF  01,9C
01470:  MOVFF  00,9B
01474:  CALL   09C0
01478:  BTFSC  19.7
0147A:  BSF    FF2.7
0147C:  MOVFF  02,5A
01480:  MOVFF  01,59
01484:  BRA    138A
....................       
....................         
....................    } // while(1)
.................... 
.................... }
01486:  SLEEP 

Configuration Fuses:
   Word  1: E800   INTRC_IO NOPLLEN PRIMARY_ON FCMEN IESO
   Word  2: 1C18   PUT NOBROWNOUT BORV19 NOWDT WDT128
   Word  3: BF00   CCP2C1 PBADEN CCP3B5 HFOFST TIMER3C0 CCP2D2 MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
